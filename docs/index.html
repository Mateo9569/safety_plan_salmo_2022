<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Safety Plan" />




<meta name="author" content="Mateo Winterscheidt" />


<meta name="description" content="Safety Plan">

<script id="pandoc-meta" type="application/json">
{"author":"Mateo Winterscheidt","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"title":"Safety Plan"}
</script>

<title>Safety Plan</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">body{font-family: Helvetica;font-size: 10pt;}h1{font-size: 12pt;}h2,h3,h4,h5,h6{font-size: 11pt;}a[href^="http"]:not([class="uri"])::after {content: "";}@page {size: 8.5in 11in;}@page:left {margin-left: 30mm;margin-right: 30mm;margin-top: 30mm;margin-bottom: 30mm;}@page:right {margin-left: 30mm;margin-right: 30mm;margin-top: 30mm;margin-bottom: 30mm;}.date{ font-size: 12px;color: Black;text-align: center;}.break-after-me {break-after: page;}</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Safety Plan</h1>
<h2 class="author">Mateo Winterscheidt</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Mateo Winterscheidt<br />
New Graph Environment<br />
<a href="mailto:mateo@newgraphenvironment" class="email">mateo@newgraphenvironment</a><br />
672-998-5293<br />
Date: 2023-08-16</p>
</div>
<p><br></p>
<div id="safety-plan---2023-054-salmo-larl" class="section level1 unnumbered break-after-me">
<h1>Safety Plan - 2023-054-salmo-larl</h1>
<p>The latest version of this pdf can be downloaded <a href="https://github.com/Mateo9569/safety_plan_salmo_2022/raw/main/docs/safety_plan_salmo-larl.pdf">here</a>.</p>
<p>A kml file containing the location of site 1 at the end of Carney Mill Road in Salmo where we are going to carry out a snorkel survey can be downloaded <a href="https://github.com/Mateo9569/safety_plan_salmo_2022/raw/main/mapping/Carney.kmz">here</a>. Site 2 in Salmo can be seen on this orthomosaic map that can be accessed <a href="https://www.mapsmadeeasy.com/maps/public/d67c01a499be4c30b7d1c74b72a4101b">here</a>. A table with site descriptions and locations is found below.</p>
<table class="table table-condensed table-responsive" style="font-size: 9px; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:site-details">Table 1: </span>Site Locations
</caption>
<thead>
<tr>
<th style="text-align:right;">
Id
</th>
<th style="text-align:left;">
Stream
</th>
<th style="text-align:right;">
Long
</th>
<th style="text-align:right;">
Lat
</th>
<th style="text-align:left;">
Description
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
1
</td>
<td style="text-align:left;">
Salmo River
</td>
<td style="text-align:right;">
-117.2730
</td>
<td style="text-align:right;">
49.17137
</td>
<td style="text-align:left;">
South end of Carney Mill Road in Salmo. Turn left onto Pearson Road to access the river.
</td>
</tr>
<tr>
<td style="text-align:right;">
2
</td>
<td style="text-align:left;">
Salmo River
</td>
<td style="text-align:right;">
-117.2655
</td>
<td style="text-align:right;">
49.18877
</td>
<td style="text-align:left;">
At the confluence where Erie Creek drains into Salmo River. Approx. 750m downstream of Main St bridge in Salmo.
</td>
</tr>
</tbody>
</table>
<p><strong>Vehicles</strong></p>
<p>Al and Mateo - 2013 Toyota Tundra black</p>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 9px; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-crew">Table 2: </span>Crew members details and emergency contacts
</caption>
<thead>
<tr>
<th style="text-align:left;">
name
</th>
<th style="text-align:left;">
email
</th>
<th style="text-align:left;">
phone
</th>
<th style="text-align:left;">
satellite
</th>
<th style="text-align:left;">
emerg_name
</th>
<th style="text-align:left;">
emerg_email
</th>
<th style="text-align:left;">
emerg_phone
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Allan Irvine
</td>
<td style="text-align:left;">
<a href="mailto:al@newgraphenvironment.com" class="email">al@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
250-777-1518
</td>
<td style="text-align:left;">
<a href="mailto:allanirvine75@inreach.garmin.com" class="email">allanirvine75@inreach.garmin.com</a>
</td>
<td style="text-align:left;">
Tara Stark
</td>
<td style="text-align:left;">
<a href="mailto:tara.stark@gmail.com" class="email">tara.stark@gmail.com</a>
</td>
<td style="text-align:left;">
250-505-9854
</td>
</tr>
<tr>
<td style="text-align:left;">
Mateo Winterscheidt
</td>
<td style="text-align:left;">
<a href="mailto:matwint45@gmail.com" class="email">matwint45@gmail.com</a>
</td>
<td style="text-align:left;">
672-998-5293
</td>
<td style="text-align:left;">
807-790-7943
</td>
<td style="text-align:left;">
Felicitas Winterscheidt
</td>
<td style="text-align:left;">
<a href="mailto:fhwinterscheidt@gmail.com" class="email">fhwinterscheidt@gmail.com</a>
</td>
<td style="text-align:left;">
519-636-5251
</td>
</tr>
</tbody>
</table>
</div>
<div id="equipment-checklists" class="section level1 unnumbered">
<h1>Equipment Checklists</h1>
<table class="table table-condensed table-responsive" style="font-size: 9px; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
Personal Equipment Checklist
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
GPS
</td>
<td style="text-align:left;">
headlamp
</td>
</tr>
<tr>
<td style="text-align:left;">
Suncreen
</td>
<td style="text-align:left;">
hard hat
</td>
</tr>
<tr>
<td style="text-align:left;">
Bugspray
</td>
<td style="text-align:left;">
steel toed boots
</td>
</tr>
<tr>
<td style="text-align:left;">
Polarized glasses
</td>
<td style="text-align:left;">
clinometer
</td>
</tr>
<tr>
<td style="text-align:left;">
Bear Spray
</td>
<td style="text-align:left;">
field vest
</td>
</tr>
<tr>
<td style="text-align:left;">
phone/camera
</td>
<td style="text-align:left;">
note book
</td>
</tr>
<tr>
<td style="text-align:left;">
battery pack booster for phone
</td>
<td style="text-align:left;">
Extra clothes
</td>
</tr>
<tr>
<td style="text-align:left;">
Hat
</td>
<td style="text-align:left;">
rain gear
</td>
</tr>
<tr>
<td style="text-align:left;">
first aid kit personal
</td>
<td style="text-align:left;">
hand lens
</td>
</tr>
<tr>
<td style="text-align:left;">
Waders
</td>
<td style="text-align:left;">
GPS Case waterproof
</td>
</tr>
<tr>
<td style="text-align:left;">
Boots
</td>
<td style="text-align:left;">
Notebook waterproof
</td>
</tr>
<tr>
<td style="text-align:left;">
Ski poles
</td>
<td style="text-align:left;">
Drysuits
</td>
</tr>
<tr>
<td style="text-align:left;">
water
</td>
<td style="text-align:left;">
Snorkels
</td>
</tr>
<tr>
<td style="text-align:left;">
food
</td>
<td style="text-align:left;">
Goggles
</td>
</tr>
<tr>
<td style="text-align:left;">
gloves work
</td>
<td style="text-align:left;">
Fanny pack
</td>
</tr>
<tr>
<td style="text-align:left;">
glasses safety
</td>
<td style="text-align:left;">
–
</td>
</tr>
</tbody>
</table></li>
</ul>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 9px; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
Crew Equipment Checklist
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Hand saw
</td>
<td style="text-align:left;">
pilon x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
Linesman Gloves x 3
</td>
<td style="text-align:left;">
Measuring board
</td>
</tr>
<tr>
<td style="text-align:left;">
Backroads Mapbook
</td>
<td style="text-align:left;">
Scale
</td>
</tr>
<tr>
<td style="text-align:left;">
Locational maps
</td>
<td style="text-align:left;">
Permits
</td>
</tr>
<tr>
<td style="text-align:left;">
Background Documents
</td>
<td style="text-align:left;">
Fish ID book
</td>
</tr>
<tr>
<td style="text-align:left;">
radio road
</td>
<td style="text-align:left;">
Site Cards / Field Guide
</td>
</tr>
<tr>
<td style="text-align:left;">
Inreach
</td>
<td style="text-align:left;">
Minnow Traps
</td>
</tr>
<tr>
<td style="text-align:left;">
Field Safety Plan
</td>
<td style="text-align:left;">
Catfood
</td>
</tr>
<tr>
<td style="text-align:left;">
first aid kit level 1
</td>
<td style="text-align:left;">
Flagging
</td>
</tr>
<tr>
<td style="text-align:left;">
First Aid binder stocked
</td>
<td style="text-align:left;">
Laptop w/basecamp
</td>
</tr>
<tr>
<td style="text-align:left;">
Throw bags
</td>
<td style="text-align:left;">
GPS cable
</td>
</tr>
<tr>
<td style="text-align:left;">
polaski
</td>
<td style="text-align:left;">
Lazer level
</td>
</tr>
<tr>
<td style="text-align:left;">
shovel
</td>
<td style="text-align:left;">
Assessment cards fish passage
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher backpack
</td>
<td style="text-align:left;">
UAV
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher pressurized
</td>
<td style="text-align:left;">
Flow meter
</td>
</tr>
<tr>
<td style="text-align:left;">
Battery booster
</td>
<td style="text-align:left;">
ATV
</td>
</tr>
<tr>
<td style="text-align:left;">
Compressor 12V
</td>
<td style="text-align:left;">
bucket rigid x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
Rubber boots (no-slip soles)
</td>
<td style="text-align:left;">
bucket foldable
</td>
</tr>
<tr>
<td style="text-align:left;">
Small BT Speaker (for bears)
</td>
<td style="text-align:left;">
clove oil kit w/ instructions
</td>
</tr>
<tr>
<td style="text-align:left;">
Oakton Multimeter
</td>
<td style="text-align:left;">
gloves leather
</td>
</tr>
<tr>
<td style="text-align:left;">
Backpack Electrofisher
</td>
<td style="text-align:left;">
sharpies
</td>
</tr>
<tr>
<td style="text-align:left;">
stop nets x 4
</td>
<td style="text-align:left;">
ATV gas
</td>
</tr>
<tr>
<td style="text-align:left;">
salt blocks
</td>
<td style="text-align:left;">
ATV lock
</td>
</tr>
<tr>
<td style="text-align:left;">
loose salt
</td>
<td style="text-align:left;">
UAV battery charger
</td>
</tr>
<tr>
<td style="text-align:left;">
dip nets x 2
</td>
<td style="text-align:left;">
wader disinfectant kit
</td>
</tr>
<tr>
<td style="text-align:left;">
tape measure hand
</td>
<td style="text-align:left;">
GPS batteries
</td>
</tr>
<tr>
<td style="text-align:left;">
tape measure eslon
</td>
<td style="text-align:left;">
ATV helmets
</td>
</tr>
</tbody>
</table></li>
</ul>
<p><br></p>
<div id="nearest-hospitals" class="section level3 unnumbered">
<h3>Nearest Hospitals</h3>
<div class="figure"><span style="display:block;" id="fig:hospital-1"></span>
<img src="data:image/png;base64,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I7XVQQDweZyFYrEUuusPaJqiCBJj/PdHn9ywfv2uu+520fnnLn/ksT32mJBO5wiScPK2a6+abRxcFCVZlI1vppO3NTS2blfCMSEw+vdc/Uh+WN+HDgQsy1x92jFLnvhH0N1NL7Gq6Zokzr+kex4JADRFFkVp/sIlwUDwnLNn2e1Wp8Nx8YVnL1h8685jdzrmyBm6rsuKIpfFBRFCHMvkckWbzRwMeMOReJ9GjIP4q2AwpfLHY0NDSyKRcLkdnbS8REmeMH7clL0mzb/5ttZobObhh40fN27D+nqtS14gEUsKgjikttJhtwJAoShsbGztychUxWz567GSoWny6BnTF91yz/VXzb7uqtnzF93+z1feKLGNWCzW2BKqcKgVLg2RvcU28ppL0kw9reiapmOMX3ps2czDDzn7gksuufSKysrKl1987ogZhxAEWRDE3ithOZahKSqfL2ICltx27z5T97rl9jsBgEQAABRJvPbm27lc4bjjjh0zcuRJx8508PZ8UXDwtqaWdjWzmqpANrclK3SfoBlGkTQjPeHgbXXVFX6vq9TyWt/YkskUXB6nuee9mnHu//nosw8//tTIKP3y6zrjrIcE/e99+rUhvfX+dz9NHDPKoASiLDvs9jXrN0kz6ZoGACRBEESPgSJRkgDAYuIoktxn8u4ESQGALMskSaayud8aW43DXnl7VekluXzxxCtuMHNcIOA/bOrkpnAMACRF/fibNTRNC6L0W0PT2NF9FwwCwBdrfp2//On/vPNB+ZNFUVyw/BkAiKWz7deToviOwtVMJrOhvplhGZdza9kGAJAkYfQTAYDNahGE3thzJ5hYFgGSJPmXX34LBPx33Lrkp5/WRCJRv8/37Tffu108w1CFopDv+KfrusPJRyJxAEAI8XZrYXu6hOxduUdDtm17jBzwui445uBcd9mNaCp77jGH9vJaTdMYitx5p50qKypuXrz040/+u/O4XerrGw85+MB5N92MMRYkqZxtGLBYzdFEEgBYhkaAlS4HDOIvisEIxx+PnkLEqqZJsixJUmVlYNSwIStWvuxwuoYPH6rICkkSgBAAzueLiqpVVQWMTkJJkkPROEMxvYedC6rTSm1yUMNycsxOO11TN+yp516o37jx8MMP+/jjT9PprM1maWgJuaxoWB99KKBiWtD6NmovCKLVbF5y652BYPCBu++UJPEf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HjZj4sQtLI4++PCjfn6AUWPGxeKJsrISUwXhgP2mjBhRAwAsy8g9EdY6QxKlbE7weV2dHb2jsWReEMs8mGPa55EIK+Wh0NrPvnB73Mvvue+Siy6sb2yprgzIkqAaDAAAARqmERgk0gEAA0i6fZuiDQBQNY2h6TNOONr887Irr5mw5/h511+DEAJFlRGurtwsYqHr+oKbbvW47clk6u+nnWaqnxkYbytf3ed1t0XiofIgQsjjcRVyeau9BwGuHiErSi5bcLscQX+o83JBlNx2G0EShq4jgsAIYUA0RWqals8X7n/+FVXXzzzu/6rKShLpzKur/ltq4z79aYPb67/klGMee+Hl5mhir/G7HzllEo0phNC/Xnn9x6bI+FHVxxxxCIGI5U8+f870o+955iVd1y486Ri/33fro08BwB2PP3PuSce57Naf6hpXvvUeTVIzjj2iorwkJwj3P7NyythdPv3ht1K/d+IuI6trqjTd+M87740ZO3aXmgpB1AHgzU/WTZu4uzkSHH3EofXRDEKIpqnVn6378MuvLRx7waknFglo9z7/ejIeOXK/yZPGjxVFCQBeePWNH+pbSkpKLzjpLwRBEASRzRUefvEVSZIP33fSpPFje2QR6YYBBvztiP2fe2dNwN1VRUrXjYIk3zLrLABACFl4LpPJOZ12jmUQAl3TyW0UFe0PLDxns/AYA0JAk9Qzz7+4aP6c1tbImNG7nHDc0V+u+/b5F1bOvuySW2+/i2HZv516qvkYbO171jMIgmAoWpIVjmUcNks8lsA23E/HWlGS8/lCacBXEvA2tbRxXK/ftaMqpg3k5LYFNpu1zOeauvto80+hIDLM5kEknkjl8oLLaefdQ6M4ggAefuypPfYcP3H8uF/rGn775bcjDzuIQITUg4zyMHYA/IkyHGbIMHvylksn7zsNilWUlpXPrhrybU10Tpt8uSX6ef6qpp101GErX/r39XMXmD2HX373zYIly1avWUv3yd4wDD0WTWg6HlETKtpsCoK4oa4JIfD73MVoAwwFDOWic099++13aioqb735psaW5kcfe1zVCA231+NzmlfUHYLuwoBymjevebc12gAAK8/lcllRElVVuf3Ouxubmo856ui5CxYdc8LJr772psflLHaWbqpr0nRj8YLrrpg1c/GN88aNHS2IkqbrA+iOQwQyEDar9U6HLd+/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" alt="Kootenay Lake Hospital - 3 View St, Nelson, BC V1L 2V1 - 250-352-3111" width="100%" />
<p class="caption">
Figure 1: Kootenay Lake Hospital - 3 View St, Nelson, BC V1L 2V1 - 250-352-3111
</p>
</div>
<p><br></p>
<div class="figure"><span style="display:block;" id="fig:hospital2"></span>
<img src="data:image/png;base64,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KW1zNDY2btiwobi4JSDi9XrXrVtrNluGHjZ01apVsVhs7dq1/fv3//XXleFweMCAgW53S45zdfW2eDw28NBDX331VZPJdNlll7319ls0Rb/2+utmk3nturVvvTXHarVeffXVxx03cd5X8z777DNVVV959VWrxVpdUz372dlHHXXUU0891aNHz5deenHZsqXDh7e0aJk165khQ4Y++uhjABCLxa688oo5c94CgOXLl8fj8WHDhomiCAArV66MRCKHHXaY2WwGIL/8stwghs1q7dOnb/rMbNq0qba2pv8hAwsLOl1b5UDoHs3K/7CkPNWXjOGPG4g/WWGcPUu77jX1htfV82crL3xjjOiBTx9GAcbUdbfTQV/4snNiD90TunAyFQ0LD88CRMHA51gPRS0dqn42kVo6kDJh/bBvWQrOORxvbibT/q0+OFe75IXtvAUYAWAqfuaf6JpN9rsvtT57u2v6WY4ZUwEI007vg86kpin85BuL3vu5cfSYPndeevj900Z7OPTcZxuzMpj20Q0yb03Hm0E/buH2z7u0ubkT1VRsdksgEE79jxBiGFZtt3wGIcQLXDwhpTZNopCU5HRZvqbr3mBkh5dMOXbUvVdffP+1l0ybfPwOD1EYN3r3R90IY4QBJZNteQnlJYWxRGI/DtWx8DwXjLTFL5x2m9Ruw3pDJ8ziE4UfBlOmAmrATagTVLyMmg/0JTeA5yT5mNV+62WZJ83lciSTuy2c7iQ4jlu6dAkAJBKJ/occkto5Y8aMUCioqOrFF18MAP955ZUHH3xow4bfp0w5BwBSFlt9ff306TfxAv/ss88CgNfrve22GWazeeEPC7/66iubzUrTtNVqnTVr1voNG1iOu/HGNhfIf155ZfToY1atWnXtNdeecvIpomiqrak566yzzCYzAKxevbqisvL77xdOmDABACYeN3H1mjWnnXaa1WJNPdqnb59Ro0ZVVFTefvvtq1atGjZsePrIS5YsueCCC1L/m83m1157HQAef+Lxr+d/rarKlVdeAQCzZj3z+eefGYb+5z9fBQAvvPDiokU/BQKBu+9uC5n9+OMP7777X7PF+vcH7mto6PI8u30hb3DkOoqqIgQ3TqLfvIYutKGmMKkPgcjAkxdQ951NIwSEGOLY8abZr2A5oS9dRBma+eV36J69AIAUXYoGfQl6lLevJhoih28AvhIA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" alt="Kootenay Boundary Regional Hospital - 1200 Hospital Bench, Trail, BC V1R 4M1 - 250-368-3311" width="100%" />
<p class="caption">
Figure 2: Kootenay Boundary Regional Hospital - 1200 Hospital Bench, Trail, BC V1R 4M1 - 250-368-3311
</p>
</div>
<p><br></p>
</div>
<div id="field-plan" class="section level2 unnumbered">
<h2>Field Plan</h2>
<p>The primary goals of what we are doing in this project include:</p>
<ul>
<li>snorkel survey to determine fish distribution and density</li>
<li>UAV survey to map fish habitat</li>
</ul>
<p>General Field work methods will generally follow procedures in:</p>
<ul>
<li><p><a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf">fish passage assessments</a> <span class="citation">(MoE 2011)</span></p></li>
<li><p><a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf">habitat confirmations</a> <span class="citation">(Fish Passage Technical Working Group 2011)</span>.</p></li>
</ul>
<p><br></p>
<p>Presence/absence of fish, species composition/density and distribution limits can be useful for prioritizing which crossings are a best fit for fish passage restoration and help inform follow up monitoring so electrofishing and minnowtrapping may be conducted. Standard Fish and Fish Habitat Inventory Standard Field Form <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/laws-policies-standards-guidance/inventory-standards/aquatic-ecosystems">site cards</a> are used to gather habitat data. Field guide is <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/sitecard20.pdf">here</a></p>
<p><br></p>
<p>We are running digital field form tests using a product called <a href="https://merginmaps.com/?gclid=Cj0KCQjwxb2XBhDBARIsAOjDZ34oq-iMid3vRrgK1ZAkJ_yiz4aWY-LLF90PHiXzELbZIrxooV9vWKYaAgl2EALw_wcB">Mergin Maps</a> which syncs with QGIS. Crews can access projects with a free account. Please send me your usernames and we can begin to share projects/forms.</p>
<p><br></p>
<p>A guide to freshwater fish id such as <span class="citation">McPhail and Carveth (1993)</span> can be useful and can be downloaded <a href="https://a100.gov.bc.ca/pub/acat/documents/r13659/486FieldKeytoFreshwaterFishes1993Part1of2_1210014849226_8e248a8d30d97e6c45ef54a340babd2ffb57b14a3b16.pdf">here</a>.</p>
<!-- and an overview map of displaying potential sample locations is included as Figure 1. -->
<p><br></p>
<div id="check-in-procedures" class="section level3 unnumbered">
<h3>Check In Procedures</h3>
<p>Call, text or inreach Tara Stark (2505059854) in the morning to share the plan for the day (i.e. name of roads and sites). Check in time is before 7 pm each evening although we regularly check in throughout the day (ex. at arrival to site, 1pm and 4pm) on the inreach or by text and report position/provide updates.</p>
<p><br></p>
<div id="procedures-for-failed-check-in---for-check-in-person" class="section level4 unnumbered">
<h4>Procedures for Failed Check-In - for Check in person</h4>
<p><br></p>
<p>Procedures are summarized in the following Figure. If phone call or inReach check-in is not received by 7pm send text to inreach units, call or text cell phones of field crew members. If no response please call accommodations then personal emergency contacts to see if they have heard anything. Wait 1 hour and text inreach, text or call cell phones and personal emergency contacts and accomodations again. Repeat after 2 hours (9 pm) - if no response then notify the RCMP of a missing persons in field.</p>
<p><br></p>
<div class="figure"><span style="display:block;" id="fig:flow-check-in-fail"></span>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABD0AAAEgCAYAAAC3hAiaAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdeVzUdf4H8Ndwq5weKGioyKGIqInXDHikqWiZadKWmp3QtcHPMq3VXSvbMith2w6oLG3bdtHKPEBd8wTEA1NERE5PEERB7vvz+wPm68wwKPeX4/V8POahM/M93jOg8H3N5/P+KIQQu0BERERERERE1MkohBBC7iKIiIiIiIiIiFqagdwFEBERERERERG1BoYeRERERERERNQpGcldANWvqKgI5eXlAIDy8nIUFRXpfU6XjY2N9HdjY2OYm5tL962traFQKFqpYiIiIiIiIqL2g6FHK6uqqkJ2djaysrKQkZGB7OxsXL9+HXl5ecjLy0N+fn6dm/rxqqqqVqnJwsIClpaWWjdra2tYWVlJz/Xp0wf29vbo27cv+vXrBzs7O3Tr1q1V6iEiIiIiIiJqDWxk2kwZGRlIS0tDamoqUlNTcfnyZWRnZ+PatWvIzs5GdnY2qqurAQBmZmawtbWFvb09rKysYGlpCRsbmzoBhKWlJaysrKRRGUZGRrCwsJDO2a1bN5iZmUn3LS0tUVxcjMrKSgCAEAJ5eXnS82VlZSguLgYAFBYW1glZcnNz6zyWnZ2NzMxMreNYWFigf//+sLW1hZ2dHezs7DBkyBAMGTIEjo6OGDRoEExNTVv1/SYiIiIiIiJqKIYeDXD9+nWcPXsWFy5ckAIO9Z8lJSVQKBTo378/hgwZgoEDB0ojI9QBh3q0hOa0k46itLRUa5RKZmYmrl+/jqysLFy9ehWpqalIT09HaWkpDAwMMGDAACkEGTJkCJycnODu7g5nZ2cYGXFgEREREREREbUdhh4aioqKkJCQgLi4OJw9exbx8fE4c+YMcnJyYGJiojWqQfPvjo6OXXqEgxAC165dqxMIpaWlITk5Gbdu3YKpqSnc3NwwYsQIuLu7Y+TIkXB3d4e9vb3c5RMREREREVEn1WVDj8rKSpw5cwZHjx7F0aNHceLECaSmpqK6uhoDBw6Eu7s7RowYAQ8PD7i7u2Po0KEwNjaWu+wO6dq1azh79qxWmJSQkIDy8nL06tUL999/PyZOnIgJEyZg4sSJsLa2lrtkIiIiIiIi6gS6TOiRk5MjBRzR0dE4efIkioqK4OzsjIkTJ2L8+PFSwMGL7tZXUVGBpKQknD17FidOnEBMTAxiY2NRXl6OYcOGYeLEiVAqlZg4cSKGDh3KFWeIiIiIiIio0Tpt6FFSUoLDhw9j79692Lt3L+Lj49G9e3d4enpKF9MTJ05Enz595C6VapWVleHUqVOIiYlBdHQ0jh49imvXrqFXr16YPn06ZsyYgRkzZmDAgAFyl0pEREREREQdQKcKPc6ePYs9e/Zg7969OHLkCIQQUKlUmDFjBqZNm4ZRo0axmWYHc/nyZa3wKisrC8OHD5cCkEmTJqF79+5yl0lERERERETtUIcOPaqrqxEZGYmwsDD8+uuvyMjIwNChQzFjxgzMnDkTkydPRo8ePeQuk1qIEAJnzpyRApDIyEgoFAo88MAD8PX1xSOPPMKpSURERERERCTpcKFHdXU1oqOjERYWhp9//hlZWVmYMmUKFi5cCB8fHzg4OMhdIrWRoqIiHDp0CL/88gu2bduGwsJCzJgxAwsXLsQjjzwCS0tLuUskIiIiIiIiGXWY0CMuLg7fffcdtm7diszMTHh7e8PX1xcLFiyAra2t3OWRzCoqKvD7778jLCwM27ZtQ0lJCWbOnIlFixbhkUcegYmJidwlEhERERERURtr16FHSUkJwsLCEBISgqNHj0KlUuGJJ57AggUL0K9fP7nLo3aqvLwc+/btk0YD9ejRA88++yxeeOEFDB48WO7yiIiIiIiIqI20y9AjKSkJGzduxLfffovy8nL86U9/wiuvvAIPDw+5S6MOpqCgAD/99BO+/PJLxMXF4YEHHoCfnx/mzZsHY2NjucsjIiIiIiKiVtSuQo/Dhw/jvffew759+zB+/Hj4+/vj8ccf5+oc1CKOHj2Kr776Clu2bEHv3r3xxhtv4IUXXkC3bt3kLo2IiIiIiIhaQbsIPQ4cOIB3330Xhw8fhq+vL958802MHj1a7rKok7p16xZCQ0Px6aefwsjICMuXL4e/vz/DNSIiIiIiok5G1tAjMjISa9aswYEDB7BgwQK88847GDZsmFzlUBdTVFSEb775Bh999BEqKirw8ssvY9myZVz1hYiIiIiIqJMwkOOkKSkpmD17NiZPnoyePXsiISEBYWFhDDyoTfXo0QMBAQFIS0vD2rVr8c0338DV1RWbN29GOxgARURERERERM3UpqFHSUkJVq9eDXd3d1RUVEhhh6ura1uWQaTF1NQUfn5+SE5Ohr+/P/z9/TF9+nScP39e7tKIiIiIiIioGdos9Ni5cyeGDx+Ob7/9FqGhofjf//7XIcKOYJUCCkXNTRWc0unOR3d069YNa9asQXx8PMzMzDBy5EgEBASgoKBA7tKIiIiIiIioCVo99Lh9+zYWLVqERx99FI8++iguXLiAp556qrVP22ICogREuF+HO19KsKomPPGPaIGqupYhQ4Zg165d+M9//oNff/0Vo0aNQkxMjNxlERERERERUSO1auhx/PhxjB49GrGxsTh27Bg++eQTWFhYtOYpW4ezG5Qd7HzJCdEAAKWbc/PraS0R/lAoFGivucz8+fORkJCAKVOmwNvbG3//+9/Z64OIiIiIiKgDabXQY9OmTZg0aRKmTJmC2NhY3H///a11KtLDJ0RACIGoACe5S+nQzM3N8e233+LHH3/EunXr8Nhjj6GwsFDusoiIiIiIiKgBWjz0EELg7bffxvPPP49PPvkEGzduRI8ePVr6NERtytfXF0ePHkVcXBy8vLyQmZkpd0lERERERER0Dy0aelRVVeHFF1/EZ599hvDwcLzyyistefjWVTvVQrrVM+dC6pVRe9O7WUowVPc6VgPPp++c92pwqrcZqub5/CPqnP+uU0yasq/ue6BQ4U7ZEfBXKKCYHQoACJ197/egPXBzc8OxY8fQo0cPeHt7Iz09Xe6SiIiIiIiI6C5aLPQQQuCll17C1q1bsW/fPjz44IMtdejWF+EPxexQKIOSIYSASA6CMnR2nXAhOtAZS7GpZhsRDj8AobP9EaF7LOdAQOdYWhf0DTyfmlNAVG1zUyWCku89ZUVvM1SfkJrzAEDobCi2zat9HckIUup5Hc3ZV/c9EALJQUCgszog8UGIuFOjX3jNNiLE566vqz3o2bMn9u7dC0dHR0yZMgVXr16VuyQiIiIiIiKqR4uFHqtXr8ZPP/2EiIgIjB8/vqUO2wYi4D87FFAGYZM6TEhOQDQAdxftcEEZlKwROPhgeZASQDySUu5yLKcArPIDELqtNhho+PnulOhfGzREocEtOvQ1Q3VygTsA+IVrBAxOmOOr+zr0aPC+el4fAKeATfcOVzqIHj164LfffsOgQYMwa9Ys5Obmyl0SERERERER6dEioceWLVuwbt06bN26FePGjWuJQ7adiG0IBaD0nQPpEt0nBEIINHrgQUoS4nWPBcDZTQkgFNsimnA+deDRAUZBAJDeA7i7QDufcYKLO3DPcKWD6NatG7Zv3w6FQoElS5agurpa7pKIiIiIiIhIR7NDj5SUFDz33HN47733MHPmzJaoqeOqHbERHeis1fPCOTC6SYeLDnSu6XsROrtu3wzdniAKBRSKdjCKovY90LdUbk34E42E5DavqlVYWVnh559/xpEjR7B+/Xq5yyEiIiIiIiIdzQ49XnrpJYwbNw4rVqxoiXo6ttopJUqNXhaat8YO1qg5jrp3iGYjUEijQ7RvIZB9PEjtexCtJ9lITogGoISePKTDcnFxwT//+U+sWbMGycmdJM0hIiIiIiLqJJoVemzduhWRkZH48ssvoVAoWqqmtqW+SA/bBe1ZFykIVjVy5ERt34u6xwIQ4V/TqLTR5/NBSHIQlIhGoHM7GMlxL+reH/FJdV5fUs3cH8xpaF+SDmLJkiXw8vJCQECA3KUQERERERGRhiaHHkIIvPfee3jppZfg7NyBP7p3CsCmICUQHQhnjTkkEf7OSFilPXJC3+gF7ekatc1NdY6FlGCo1rrVNPZsxPk0a4wK9wMQitmq4LqBij6100z0qhNI6L6Ou7jnvj4ICffT+/oCowG/VQHQzTziO0GTj48//hi7d+/GiRMn5C6FiIiIiIiI1EQT7dmzR5iYmIhr16419RDtSnKQUgCQbn7h+h+HMkgki2QRpITW48qgZM2DCWWdfZpzvhrhfurHlSJI94B3OTb8woUI99N+DH4i/F6vQ60p++q+B/AT4XUPLPzu8T51JHPmzBFPPPGE3GUQERERERFRLYUQQjQlLHnmmWdw69Yt/Pbbb03ZnajT+eWXX7BkyRJkZWXB3Nxc7nKIiIiIiIi6vCZPbwkPD8f8+fNbshaiDm327NkAgIMHD8pbCBEREREREQFoYuiRnp6O7OxsKJXKlq6HqMMyMzPD6NGj2deDiIiIiIionWhS6JGcnAwTExM4OXWyZTiImsnd3R0XLlyQuwwiIiIiIiJCE0OPW7duoWfPnh13mVqiVtKrVy/cunVL7jKIiIiIiIgITQw9hBAMPIj0MDQ0RFVVldxlEBEREREREZoYelhbWyM3N7elayHq8G7evImePXvKXQYRERERERGhiaGHo6MjSktLcenSpZauhxoqJRgqhQKK2psqOEXvZne2UaGeTagFXbhwAY6OjnKXQURERERERGhi6OHs7AwrKyscO3aspevp8FKCVTUhg39E657IKQBRQiA56O4r6EQJgXC/1i2FalRVVeHkyZMYO3as3KUQERERERERmhh6GBgYYMaMGfjtt99aup4OLzkhGgCgdHNuk/M5zfHFvRYOdnbj0sJt4ffff0dxcTGmTp0qdylEREREREQEwKipOz7++ON4+umnkZeXB2tr65asqUPzCREQIXJXQXLYvHkzZs6ciV69esldChEREREREaGJIz0AYO7cuejduzc+++yzlqyHOhKdviJ1b/5o5Uk+7cbly5cRFhaG1157Te5SiIiIiIiIqFaTQw9jY2OsWLECn376KbKyslqypiaRemkoFFAFRyBYVXvhrQpGyp2NtC/S9fXdiPDXvnDX3eYux5DOqW4sqrutuhatxzUajDakPt1tloY1/E1Krqf5aX11IgL+zWiEqgxajiSN98Q/QvN4Os1XNd53VXCK1tdTCk8a2LxVDm+99RZGjx6NBx98UO5SiIiIiIiISE00Q0VFhRg1apR44oknmnOYlhPuJwAIQCmCksOFHyAAPxGu8ZwyKLlm2+QgoQQE/MLr7K+7jXS/KccQtXUog0Sy0BQu/KAUdzZryrGTRZASOo/VlRykrHlfNGpQP3bvOpNFkFKjTu0DC6VmfVr71L7vmudH3ce06pa+fnreB6VSKKXa1K+7nrra2J49e4ShoaGIiYmRuxQiIiIiIiLS0KzQQwghjh8/LoyNjcXmzZtbop7m0Q0pJPov6MP9NC/E9WxTexFec13fkGPor0F9ga+VD2gFBk2s766vWXMTpZ6AQB0c1A0i6q+zgcL99IYZ2ofRE1zofS1166z/mG3v+vXrwt7eXgQEBMhbCBEREREREdXR5OktamPHjsVHH32EF198EadPn27u4VpHShLiASh958BJ4+GaVU1CsS0CQMQ2hOpu4xMCIQRCfBp4jHqoV1gJ1dgoZVcCfJf7NK++ZnHCHF/t2p0CVsHvbnU2SAqC1wKrAu5Vpfr80UhIblzl7UV5eTmeeOIJ9O/fH+vWrZO7HCIiIiIiItLR7NADAAIDAzF//nz4+PggNTW1JQ7ZspITEA0gOtBZq1+Hc2B02xzDKQCr/ACErq3tixGB9QnzIOUCDTh2SlJ8w2ttMh/M060zzA1zGpGypAQvRZjvcjQmJolPaj+9ORqquroaTz/9NBITE7F161aYmprKXRIRERERERHpaJHQAwA2btyIUaNG4cEHH0R6enpLHbZlOLtBCUAZlAxRM6VH6xbSkCv0Zh7DZ54fgGiE7UpBSvBaYJ7GDg04tpOLe5NffmP4LA+CsrZORGwDVgU0YmRJBNYHujdglIc2d5eWGbvSVqqqquDv74+IiAjs3r0bDg4OcpdEREREREREerRY6GFsbIyff/4Zzs7O8PLyQkJCQksduvmcXOAOIDpsF+qMKYjwr1kFpDZ4qLtNCoJV/ohoyDHuxmc5gpRAdOBSLE3whdaMkYYc22ce/OrbpklSsCssGoCfVv4Cpznwra1TpZPN3POIwWsRH9TQUR71nL+dKy8vx6JFi/DLL79gz5498PDwkLskIiIiIiIiqkeLhR4A0L17d+zYsQMqlQoqlQoREXdpdNEaaqeJ1OWD5TWJA5w1l4FNCYZqrRs2BTgBTgHYpGebCH9nJKwKgU9DjnHXGu70sICbbl+Ohhz7zjZL76xxi+ClgfWcT1c0ApfeWb43JXgpAqMBv/AQnZDCCQGrakaloFHTVO49yiN0bd3zK/WEJNENaPLRNtN9tGVnZ2P69Ok4fPgwDh48iHHjxrV5DURERERERNQIrdEdtaqqSvzlL38RhoaG4v333xdVVVWtcRotd5ZFVd/0LGeqXv5UfauzPGvd49RZHeQux6hTQ52dw4Wf7iokzapPKYLCNffRf+zkIKVQBoVLy9vW+/5o1dm45WBrzlHPDuqldpV3eW81lqu989rVyw5r71Ozqs3d3ueWd+zYMeHg4CA8PT3FlStXWv18RERERERE1HwKIYRorUAlLCwML7zwAsaOHYvNmzfD3t6+tU5FLSoC/v5ASIOandRur9iGeUJ31Ij6aX8oZofCL7yB/VPakerqanz00Uf461//isWLF+Pzzz9Ht27d5C6LiIiIiIiIGqBFp7fo8vX1xenTp1FcXAx3d3d89dVXqK6ubs1TUgtICd4Gt0YsU9u4Xh4dxx9//AEvLy98+OGH2Lx5MzZu3MjAg4iIiIiIqANp1dADAAYPHozDhw9j9erVePPNNzF+/HicPHmytU9LjRIBf4UCClUwUlKCsVRzOd177uoP5wau2NJRlqa9ffs2XnvtNXh6euLq1asIDAzEwIEDUVZWJndpRERERERE1AitOr1FV2ZmJlasWIEff/wRixYtwqefforevXu31empXikIVjkjMBqAMgjJUY1ZpvbuglWKmuNK/BBe3zSYdmDHjh14+eWXYWpqimXLluHkyZM4duwYEhMTYWRkhNGjR2P8+PEYP348JkyYAEdHR7lLJiIiIiIionq0aeihdvDgQbzyyiu4evUqXnrpJaxcuRLW1tZtXQaRZN++fVi1ahX++OMP/N///R/WrFkDMzMz6fmCggKcOXMGsbGxiIqKwsGDB3Hjxg1YWVlh7NixUKlUGDNmDFQqFXr27CnjKyEiIiIiIiI1WUIPACgvL8c333yDDz/8EAUFBQgMDERAQADDD2ozQghs374d7777LuLj47F06VK8/fbbGDRoUIP2z8jIQFRUFCIjIxEbG4uTJ0+irKwMjo6OUgji5eWF0aNHw8Cg1WeSERERERERkQ7ZQg+18vJyfP/99/jggw+Qm5uL1157DQEBAejVq5ecZVEnVl1djV9//RXvvfceEhMT8eyzz2LlypVwcHBo1nErKioQFxcnhSCxsbFISEiAubk5Ro4cKYUgkyZNQt++fVvo1RAREREREVF9ZA891CoqKvDTTz/h/fffx6VLlzB37lz4+flh2rRpUCgUcpdHnUBWVha+//57hISE4Nq1a3j66aexevVqDBgwoNXOmZmZiZMnT0ohSGRkJPLy8mBnZyeFICqVCp6enlrTaYiIiIiIiKj52k3ooVZdXY39+/cjNDQUv/76K5ycnPD000/jhRdeYK8EapLY2FgEBwfjP//5DwYOHIjnn38ezz77LPr06dPmtVRVVSExMVHqDRIZGYnExEQYGBjAxcVFCkHGjBkDNzc3Bn5ERERERETN0O5CD00XL15EaGgoNm7ciMLCQjz++ON44oknMHXqVBgaGspdHrVjqamp2LJlC7777jukpaVh7ty5ePHFFzF9+vR2FySom6SqQ5Bjx47hxo0b6NevHzw9PTFmzBhpVIiNjY3c5RIREREREXUY7Tr0UCsvL8e2bdvw3Xff4ffff4e1tTXmz58PX19fTJ48mQEIAQDS0tKwZcsWbNmyBbGxsXB1dcWiRYvw3HPPwd7eXu7yGkVfk9TKykq4urpqhSBskkpERERERFS/DhF6aLp16xZ+/fVXbNmyBb///jt69uyJ+fPn47HHHoO3tzdMTEzkLpHaUHJysvT9cPLkSbi4uMDX1xcLFy6Eh4eH3OW1GN0mqVFRUUhLS4OFhQU8PDykEGTy5MmwtbWVu1wiIiIiIqJ2ocOFHppyc3OxY8cObNmyBXv27IGxsTGUSiWmT5+O6dOnY8yYMXKXSC2sqKgIR48exb59+7B9+3acP38egwYNwty5c7Fw4UJ4eXnJXWKbycjIkBqkRkVFITo6GsXFxbCzs9PqDcImqURERERE1FV16NBDU15eHvbv3489e/Zg7969uHjxIgYPHoyZM2dixowZmDp1KqytreUukxqpsrISp06dwt69e7Fnzx7ExMTA1NQUU6dOxYwZMzBz5ky4uLjIXWa7UFlZiQsXLmg1ST1//jyMjIzg4eEhhSBjxozB8OHD5S6XiIiIiIio1XWa0ENXWloa9u3bh3379mHv3r24ffs2HB0dpQs/9kNon/Lz83H8+HFpGod6iVdHR0c89NBDePjhh+Ht7Q1TU1O5S+0Q8vPzERcXJ4UgMTExyMnJkZbMVd+8vb0ZChIRERERUafTaUMPTeXl5YiNjcXRo0el27Vr12BjY4MJEyZINw8PD/Tr10/ucruM4uJiJCQk4MSJE4iJiUFMTAySkpLQvXt3eHp6YuLEiZg4cSKUSqUsy8t2VmlpaVKoFBsbixMnTqCqqopNUomIiIiIqNPpEqGHPpcvX0Z0dDRiYmJw9OhRnD59GuXl5ejTpw88PDzg4eEBd3d3eHh4YPjw4ejWrZvcJXdYQgikp6cjLi4OZ8+eRVxcHOLi4pCamoqqqioMGjQISqUSEyZMwMSJEzFq1CgYGRnJXXaXUVRUhD/++EMKQY4cOYKLFy9KTVLV/UEmTJjA8ImIiIiIiDqULht66KqoqEBiYqJ0UX727FmcPXsWV65cgaGhIZycnDBs2DA4OjpiyJAh0p8DBw7kijG1rl+/jtTUVKSlpSEtLQ2pqalISkpCQkICCgoKYG5uLgVJHh4eGDFiBEaMGAEbGxu5Sycduk1So6KiUFJSUqdJ6tixYznViIiIiIiI2i2GHveQm5uLuLg4xMfHIzExUbqgT09PR1lZGQwNDTFgwAApCHFwcIC9vT369u0LOzs79OvXD7a2tjA2Npb7pTTLrVu3cP36dVy/fh2ZmZnIzs7G5cuXkZ6eLgUdxcXFAID+/fvD0dERjo6OcHJykoKOwYMHQ6FQyPxKqCnUTVLVvUFiY2PZJJWIiIiIiNo9hh5NVF1djWvXrkkjGtRhyOXLl6VgQB0CAEDfvn1ha2srBSHW1tawtLSEpaUlrKystO6rbxYWFjA2Noa5uXmz662oqEBhYSHKy8uRn5+P/Px85ObmSn/XvOXm5iI7OxvZ2dm4du0asrOzUVZWBgAwNDSEra0t+vXrpxVuaI6A4fKoXcPt27dx4sQJKQQ5evQobt68qdUk1cvLC0qlEt27d5e7XCIiIiIi6oIYerSigoICKTTIyMhAVlaWFIjcvn0b+fn5uH37NvLy8lBQUID8/HyUlpbe9ZgWFhZSvwsjIyNYWFhIz5WXl6OoqEi6n5+fj6qqqnqPpVAoYG1tDSsrqzqBizrYsLe3h62tLfr37w9bW1vY2tqyuSXV615NUtVTY4YNG8bvIyIiIiIianUMPdoZ3ZEYAFBaWoqSkhJpm7y8PKi/bOqgQzcAMTc3l6bUGBgYwMrKCgDQvXt3rZEkRK1Jt0nq4cOHcenSJVhaWmLEiBFSCDJx4kT07t1b7nKJiIiIiKiTYehBRG1K3SRV3R/k1KlTepukjhs3jk2CiYiIiIioWRh6EJGs6muS2r17d4waNUrqD+Lt7Y3BgwfLXS4REREREXUgDD2IqN3RbZIaHR2NW7dusUkqkUzKyspw+/ZtFBYWAqj5N1pdXS09p9m4W3MKZklJCUpLS6UeUmrdu3eXlrvWnIIJ3JmeaWRkBCsrK63niIiIiBqLoQcRdQiaTVKjoqLwxx9/wMDAAC4uLlpNUt3c3Lg0MpEe1dXVyMrKQmZmJjIyMpCTk4Pbt2/XueXl5SEvL0+635Am22qWlpYwNDQEAJiYmKBHjx7Sc1VVVcjPz5fuFxQUoLKyskHHtbGxkQIQzZt6BTQrKyvY2NjAxsYG/fr1k1YYYyhKREREDD2IqEMqLCzE6dOnpRDk8OHDyMrKgqWlJcaNGyf1BlEqlejVq5fc5RK1qoyMDGRmZkqBhuaf6r9nZWVJK3p169YNtra2eoMEzRBB9zEzMzOtRtm6TbSbSr2supp6JElubq7eYOZuIU12drZ0HEtLS/Tv318KQdR/9u3bFwMGDEDfvn3h4ODApdaJiIg6MYYeRNRp6DZJjY2NRWlpKRwdHaUQhE1SqaPKzc1FWloazp07h4SEBKSlpSEtLQ1JSUkoKCgAAJiZmcHGxgb29vaws7Or9087O7tOOyKqvLwcOTk5UtiTm5urNwy6dOmSFALZ2NjA0dERbm5uGD58OBwdHeHo6AhXV1eYm5vL/IqIiIioORh6EFGn1dAmqZMmTcKgQYPkLpcIhYWFiIuLQ3x8PFJSUrRuJSUlMDQ0xMCBA+Hk5CTdnJ2dMWTIEPTv3x+WlpZyv4QOo6KiAllZWbh48SKSk5PrvN/5+flQKBQYMGCA1vvt6uqKkSNH8v8MIiKiDoKhBwP5jroAACAASURBVBF1KdevX8eJEycQGxsrjQrJzc2VmqRqLpvbrVs3uculTuzq1as4c+YMzpw5g9OnT+P06dNITU2FEAKDBw+Gs7OzVrDh5OSEwYMHc5RSG8nOzkZycnKdQOTChQsoLCyEtbU1Ro0ahZEjR0p/Dh8+nF8fIiKidoahBxF1aVVVVUhMTNQKQTSbpGqGIGySSk1RXV2N8+fP448//tAKOHJyctCtWze4u7tj1KhR0oWzh4dHi/TJoNZRXV2NlJQUnDlzRutrmpGRAWNjY7i5uWmFIZ6envx6EhERyYihBxGRjoKCApw5c0YKQQ4dOoTs7GxYWVlh7NixUgiiUqnQs2dPuculdqayshJnzpxBZGQkoqKicODAAeTk5MDa2hrDhw+XplUNHz4c7u7u0tKt1LHl5eUhPj5eClATEhIQHx+PyspKuLq6SgHq5MmTMXDgQLnLJSIi6jIYehARNUBGRoZWb5D6mqSOHz9eWtmCuob8/HxERUUhKioKR44cwYkTJ1BWVobhw4fD29sbKpUK3t7euO++++QuldpYSUkJjh8/jiNHjiAqKgrR0dHIz8+Hk5MTvLy8pO8PV1dXuUslIiLqtBh6EBE1QUVFBeLi4rRCkISEBJibm2PkyJFSf5BJkyahb9++cpdLLai0tBSHDh1CREQEDh06hLNnz8LIyAienp7SRaxKpYKNjY3cpVI7U1VVJf2/ob5lZGTA1tYWXl5emDFjBnx8fODg4CB3qURERJ0GQw8iohaSmZmJkydPSiFIZGQk8vLy6jRJ9fT0hJmZmdzlUiNcvnwZERER2LVrF/bv34+KigpMmjQJU6dOhbe3N8aOHcuvKTVJamoqIiMjcfjwYezZswfXrl3DiBEjMHv2bPj4+EClUsHIyEjuMomIiDoshh5ERK1Es0mqempMYmIim6R2AFVVVTh9+jR27NiBnTt34tSpU+jTpw9mzpyJhx9+GDNmzICVlZXcZVInlJaWJn3fHTp0CCYmJpg6dSoefvhhPPTQQ7C3t5e7RCIiog6FoQcRURtSN0lVhyDHjh3DjRs3YG1tDU9PTykE8fLy4vSINlZcXIzw8HBs3boVe/bsQUFBASZOnCh94j5q1Ci5S6Qu5tatW9i7dy927dqFPXv24ObNmxgzZgzmzZuHhQsXwtnZWe4SiYiI2j2GHkREMtNtknry5ElpxQd1g1QvLy+MHj0aBgYGcpfbqZSUlCA8PBxbtmzBzp07YWBggIceeghz587FjBkzuDoPtRvV1dU4ceIEdu7ciV9++QUJCQkYPXo0fH19sXDhQgwZMkTuEomIiNolhh5ERO1MQ5ukTp48Gba2tnKX2yHFxsZi8+bN+Ne//oWSkhJMmzYNCxcuxPz582Fubi53eUT3dO7cOWzZsgVhYWE4f/48xowZgyVLlmDRokXo3bu33OURERG1Gww9iIg6gIyMDCkAUS99WVxczCapjXD58mV89913+OGHH3Dx4kVMnz4dS5cuxSOPPILu3bvLXR5Rk50+fRqbN2/Gv//9b9y+fRtz587F008/jZkzZ3J0GBF1WuXl5SgqKkJubi6KiopQWFhY731N+fn5qKqqku4XFRWhvLy8zvGNjY21PggxMDCo08/L2toa5ubm6NGjB8zNzeu9b2Ji0sKvnhqDoQcRUQdUX5NUQ0NDeHh4SL1BxowZg+HDh8tdrmyqqqoQERGBkJAQREREwMXFBUuXLsXixYvRv39/ucsjalGVlZXYvXs3Nm3ahB07dsDOzg5+fn549tlnuXQ2EbV7N27cQE5ODm7cuIEbN24gKytL6zHN+7m5uXcNKqytraXgQTO4sLS0hKGhoXS/R48eWoGEQqGA5uVxRUUFCgsLpfvV1dW4ffu2dF83XCksLERFRYXeumxsbNC7d2/06dMHtra2sLW1RZ8+fdC7d+869/v06cMG9y2IoQcRUSeRn5+PuLg4KQSJiYlBTk4O+vXrB09PTykE8fb2hrW1tdzltqqbN28iJCQEISEhyMrKwoIFC/Diiy/C29tb7tKI2kR2dja+++47fP3117hy5QrmzZuH1157DSqVSu7SiKgLKi8vx5UrV3D58mVcvnwZFy9exOXLl3Hp0iXpsbKyMml79YV/79690bt3b/Tr10/rfq9evaQRFRYWFlLIYWpqKuOrrKE5AkUdiBQWFuLmzZtSgJOTkyOFOOr7OTk5UuBiamqK++67Dw4ODnBwcMDAgQMxcOBA6b6Dg0O7eK0dBUMPIqJOTLdJ6okTJ1BVVdVpm6QmJycjKCgI33//PWxtbfHyyy/jmWeeYY8D6rKqq6vxv//9D1988QV27tyJcePGYdmyZZg/f77Wp51ERM1VVVWF9PR0nD9/HomJibhw4QISExORnp6OzMxMCCFgaGgIe3t7DBw4EIMGDdK6iL/vvvukUMPIyEjul9PmqqqqpPDj6tWrWqGQOiS6du0aKisrAQB2dnYYNGgQhg4dCldXVwwdOhTDhg2Do6Njl3z/7oahRxsQQkgp3u3bt1FYWIjbt28jPz8fhYWFKCgoQGFhoZQGFhYWori4GGVlZSguLpaOo3tfnSKq6c47MzIygoWFhXTf0NAQlpaW0uPqOWbqm7W1NSwsLLTuqxNV9ggg6hyKiorwxx9/SP1BIiMjkZ6eDgsLC3h4eEi9QSZMmIA+ffq02HljYmIwfvz4VhuqGRsbi/fffx+//fYbPD098frrr2PBggW8qCPSkJSUhA0bNmDz5s3o27cvli9fjmeffZafFhJRo1RUVODcuXOIj49HYmKidEtOTkZ5eTm6desGV1dXuLq6Shfh6lEKAwYM4AV5M1RWViIjI0MKQtQh04ULF3DhwgUUFRXB2NgYTk5OGDZsmBSGDB8+HCNGjOiyvUUYejRDXl6elL7duHEDmZmZWnPQsrOzpfuazXJMTU1hbm4OKysrWFpaSiGDOohQBw+ajfVMTEzQo0ePeu+r6c47q6ysREFBQZ37eXl5UsBSUFCgFcKoH9NkaWkpDSvr06cP+vXrJ807s7W1Rf/+/TFo0CDY2dl1ik+LiboS3SapUVFRKCkpgZ2dnRSCjBkzBmPHjm3yxVG/fv3g4OCAb7/9FiNGjGix2o8fP4733nsPu3btwuzZs7Fy5Up4eXm12PGJOqOcnBx88cUXCA4ORvfu3bFixQo8//zz/ICDiOqorKzEhQsXpN8TYmNjcerUKZSUlMDGxgaOjo5wc3PD8OHDpb8PHTqUHzrIJDc3F+fOnUNCQgLS0tKkv6enp8PQ0BAuLi7SSF/1rVu3bnKX3eoYetxFbm4uLl68iEuXLuHixYtat0uXLiEvLw9ATQMc3RBAc96Z5nM2NjYdJmHLy8vDjRs3kJ2dLc0705x7dv36denv2dnZAGrCGPW8s0GDBkl/qm/9+/dnKELUzmn+gqOeGnP+/HkYGRk1qUnq1atXcd9998HQ0BBCCPzf//0f1qxZ06ylYePi4vDWW28hIiICDz/8MP76179izJgxTT4eUVdUUFCAzz77DBs2bICJiQlWr16N559/np/CEnVhiYmJiIyMxIkTJ3Dq1CnExcWhvLwcDg4OGDNmDO6//37pTzZI7jhycnKkwEr9Z3p6OoyNjeHu7o4xY8bA09MT3t7eGDZsWKdrosrQA9qJmGYylpaWBgAwMzODvb09HB0dtW52dnawt7fH4MGDO903RmOVl5fj6tWrSEtLQ0ZGBjIzM6X3MC0tDZcuXUJVVRVMTEzg5OSklQYPHz4cbm5uXSJlJOqo8vPzcfz4cak3yNGjR3Hz5k1pyVx1bxClUlln+dctW7Zg0aJFUjdzExMTWFpa4pNPPsFTTz3VqDquXr2K1atXY/PmzZg1axbef/99jBo1qsVeJ1FXVFhYiM8++wzr1q1Dv3798MEHH+DRRx+VuywiamXV1dU4d+4cDh48iCNHjuDw4cPIysrCgAEDMH78eK2Qg72xOp9bt25JIUhsbCyOHz+OS5cuoU+fPvD29sakSZMwadIkeHh4dPiRO10q9FDPZT958iTi4+Nx7tw5JCYmIi8vT5r7pB6SNXz4cAwdOhSDBg2CjY2N3KV3eOXl5bh8+TKSk5Ol9z0hIQHnz5+v8/67ublJaSOXlCRqv9LS0qQQRF+TVPXUmI0bN+Kf//xnnaXlDA0N8cADDyAkJASDBw++67mKi4vxwQcf4JNPPoGbmxvWr1+PqVOntubLI+pycnJysHbtWnz55ZcYN24cPvvsM4aKRJ3M6dOnsX//fhw6dAiRkZG4desWhgwZAm9vb0yZMgXe3t5wdHSUu0ySyeXLl3Ho0CEcPnwYhw8fRlJSEqysrODt7Q1vb29MmzYN999/f4f7wL/Thh7l5eU4c+YMTpw4gZMnT+LkyZNISEgAALi6umLkyJFSsOHm5gYnJycYGxvLXHXXlJGRgfPnz+P8+fPSaJtTp06hsLAQdnZ2GDt2LDw9PeHp6YmxY8cyaSZqpwoLC3Hy5EnExMQgJiYGx44dw/Xr12Fvb4+MjAy9+6in+61cuRJvv/223p4h27dvR0BAAMrLy7F+/Xo88cQTHe6HbccRAX/FbIRqPqRUQglfbIoKgJNcZVGbSktLwxtvvIHt27fjlVdewbvvvgsrKyu5yyKiJigpKcGBAwewY8cO7Nq1C1euXMGwYcOkT/EnT57MDxmpXpmZmVIAcujQIZw7dw729vaYM2cOHnroIUyfPr3OCN/2qNOEHjk5OTh8+DAOHjyIo0ePSvPPhgwZIl00jx07Fvfff3+z5pFT26iqqkJiYiJOnjwpBVdnzpxBaWkpBg0ahHHjxmHSpEmYOnUq3Nzc5C6XiOqRmpqKYcOGSVNb6mNsbAx7e3t8/fXXePDBBwEA165dw0svvYTdu3fjz3/+M9asWaO1IhW1sJRgqJwDgaBkRAXUxhsR/lDMDgWUQUhWhx61j/mFC4T4yFkwtbaIiAj8+c9/RlFREf7xj39g4cKFcpdERA1w48YNREREYOfOndi9ezcqKirg5eWF6dOnY968eXB1dZW7ROqgsrOzsXv37jrfWw899BAeffRRODg4yF2iXh029Lh16xYOHz6MAwcO4ODBgzh79izMzc3h5eUFLy8vaWRAz5495S6VWkhFRQXOnj2LEydOICYmBocOHUJ6ejr69u2LyZMnY+rUqZgyZQqGDh0qd6lEVCs2Nhaenp4N2tbAwABCCPzpT3+CSqXCqlWrMHToUHz99ddwd3dv5Uopwl+B2fEa4UatlGAVnMN8GXp0UaWlpfjggw/wwQcfYP78+fj888/Rq1cvucsiIh03btzAf//7X/z73/9GTEwM+vXrhzlz5mDOnDl48MEH9a76SNQcJSUl+P3337Fz507s2rULV69ehaenJxYtWoQ//elP6Nevn9wlSjpM6FFZWYkjR45g586d2L9/P+Li4tC9e3eoVCpMmTIFU6ZMgaenJzuOdzGXLl3CwYMHceDAARw4cACXL1+GnZ0dpkyZglmzZmHOnDn85YxIRp9//jneeOMNlJaW1ruNgYEBTExMIIRAeXk5hBBQKBRYunQpvvnmmw7fPKtjSEGwyhmB0X4IFyHQzjIi4K9KwvL2EHrUjkZxZ+DS5k6dOoWnn34aN27cwDfffIM5c+bIXRJRl1dcXIzffvsNP/74I/bu3Ys+ffrgiSeewOOPPw5PT09OBaU2dfr0aYSFheHHH3/EtWvXMH36dCxatAiPPvqo7DMt2nXoUVhYiN27d2P79u3YtWsX8vPz4e3tjenTp2PKlCkYN24cQw7SkpaWhoMHD2L//v3YvXs38vLy4OXlhblz5+KRRx7BkCFD5C6RqEtZtGgRfvrpJ6l3R1lZGQDAyMgItra2GDhwIFxdXTFo0CBUVlYiNDQUvXv3xr///W+MHDlSztK7nAh/BWaHQnsqi/YWdft9AIBfOIQ6gagNJaL1PBesUiAwWv1wODD7zrGUmlNq7labdFiGHnIoKyvDmjVrsH79eixbtgx///vf+XsYURsTQmD//v3YvHkzfv31VygUCsyfPx+LFy/G1KlTYWBgIHeJ1MVVV1cjMjIS//rXv7B161aUlZVh3rx5WLJkCWbOnClPGCfamczMTPHVV18JHx8fYWpqKszNzcVjjz0mfvjhB3Hz5k25y6MOpLKyUhw8eFAsW7ZMDBkyRAAQ7u7u4u233xbHjh2TuzyiLsHf31+88MILYu3ateKHH34QR44cEVeuXBFVVVXSNtXV1eLjjz8WxsbG4oUXXhAlJSUyVtyFJQcJJSAg3fxEuL7twv0EAOGn+2Tt48qgZO3jaWyYHKSsc2z1Y9J+dy1RKQClaMCm1Ip2794tevfuLby8vMTVq1flLoeoSyguLhahoaHC3d1dGBkZiYcfflj85z//EcXFxXKXRlSv0tJS8fPPP4tHH31UmJiYCFdXV/H555+LwsLCNq2jXYQepaWlYvv27WLhwoXC2NhY9OnTRyxZskSEhYW1+RtCnVdqaqoICgoSKpVKGBgYCAcHB7FixQqRmpoqd2lEXVZZWZlYunSp6N69u9i8ebPc5ZAIF35awYee8ENv6FG7nzJIJGttqrO/3n2TRZASDQozGHq0H1euXBFKpVLY29uLU6dOyV0OUaeVmZkp/va3v4nevXsLKysr8dprr4mLFy/KXRZRo12/fl18+OGHwt7eXlhaWorXXntNpKent8m5ZR3/FBsbi4CAAAwYMACPP/44ACA8PBxZWVnYvHkzFi5cyKY71GIcHR0REBCAyMhIXL58GcuWLUNERAScnZ3h5eWF0NBQFBQUyF0mUZeRm5uLWbNmYc+ePTh48CCWLFkid0kEH4QIASHC4Sc9ForZCn9E3G23lCTEA1D6ztGaFuPspgQQim133dkJc3yVAKKRkNyM0qlNDRgwAAcOHMC0adPg7e2N7du3y10SUaeSkJCARYsWwcHBAWFhYVi7di0yMjIQHByMgQMHyl0eUaP17dsXK1asQGpqKjZs2ICDBw/C2dkZCxcuxOnTp1v13G0eeuTm5uLDDz+Ei4sLxo0bh4SEBGzYsAE3btxAWFgYpk+fzqY71Or69++PgIAAnDlzBpGRkRgxYgRWrlwJe3t7PPPMMzh16pTcJRJ1allZWZg0aRJu3LiBmJgYjB07Vu6SSItu+HGP4CI5AdEAogOdoVAopJtzYPRddqorPiml6SVTmzMxMcGmTZvw+uuvY8GCBdi0aZPcJRG1uVdffRW//PLLPZdmb6grV67gueeeg4eHB7KysrBjxw6cO3cO/v7+6N69e4ucg0hOZmZmePbZZ3HmzBns2bMHxcXFGDNmDBYvXoz09PRWOWebhR5paWl47bXX4ODggK+++grPPPMMLl26hP/9739YvHgxR3SQbCZOnIgvv/wSGRkZ2LhxI65duwZPT09MmzYN4eHhEO231y9Rh5SZmYmpU6eiR48eOHLkCD+xag9SgqHy15dq+GB5kPLe+zu7QYmahqSiZuqs1q2hTUfdXepvZkrtk0KhwDvvvIPPPvsMzz33HDZu3Ch3SURtauvWrViwYAH69euHt956CykpTQtvc3NzsXLlSri6uiIuLg579uzBvn375Gv8SNQGHnjgAezatQtRUVG4evUqXF1d4e/vj+vXr7foeVo99Dh16hSeeuopuLq64siRI/j888+RkpKCt956CwMGDGjt0xM1mJmZGRYuXIi9e/fi9OnTcHJywoIFC+Di4oLg4GCUlJTIXSJRh5eVlYUpU6bAxsYGe/fuhbW1tdwlkVroWgTX+7u6Em7Od9nXyQXuAKLDdqHOISL8oar/wABSsCssGoAf5nFFlg7rxRdfxJdffgk/Pz8GH9SlFBcXAwBu3bqFDRs2wNnZGSNHjkRoaGiDfnesqKjA+vXrMWTIEPzyyy/4/vvvcfz4cUybNq21S+/gIuCvMbJQoVBAoVJBpQqu+3OI2r0JEybg4MGD2LJlCyIjI+Hi4oL33ntPWvWvuVptydqjR49ixYoViIyMxJw5c/D6669jypQprXEqolaTkZGBf/zjHwgJCYGZmRlWrlyJl19+GcbGxnKXRtThFBcXY+rUqQCA33//XfY120mDxlKz2svB1ixTG6+5pGyEPxSzQ+ssM5sSrKqZzqK7hO1SYJN6CdzafTWXxVXvd69la2t2r1m6tiHbkjxCQkLw6quvYseOHZg1a1azj1dWViZdVObm5gKo+b9E8xdh9eMAUF5ejqKiIul+UVERysvLpft5eXnSCM6KigoUFhZKz+keFwAqKyvr7fdVWFiod0pDdXU1bt++rXcffedoa4aGhrC0tGzUPpaWljA0NKzzePfu3WFqaqr1mIWFRZ2ljG1sbLTuGxkZwcLCQusxU1NTafqG5vPGxsbSz4v6/m5iYiKNGtf8e1swNTXV+h4DakZAGRgYwMzMDE8++SReffVVeHh41Nn32LFjeOGFF5CZmYl3330Xzz//PH/HbIjan1nQ87NJa9n12se4zHnHUlVVhU2bNmHVqlWwtLREaGgoJk2a1KxjtnjokZqairfeegs///wzHn/8caxevRrDhg1ryVMQtbnCwkKEhITg73//O3r16oUPP/wQ8+fPl7ssog6jqqoKjz32GM6cOYOYmBjY2trKXRJpqg0nfN0DERiq/VTdXxZrghBpM81fMDXCkzrPAXcCE6US0dF3+n3c6xdSddihi7/Itk9/+ctf8Nlnn+Gxxx6TLuDUYUNJSQlKS0u1ggF1eKAZQty+fRvV1dWNOq/uhXS3bt1gZmYm3beysoKBQc0gZ90Lf91tgfov9DUvtnXpu+DXV1t7cbeARp+qqirk5+drPaYZTKnpC3fy8/NRVVUl3RdCIC8vT2ub0tJSaXSE+ntF9++NoRmkqAMaMzMzdOvWTQpH1F9P9feEQqGQRiGqwxr1947669ujRw+YmJjAzMwMkyZNuutUaFNTU5SVlWHEiBF49dVXsWjRIpiYmGD16tX4+OOP8eSTT+LTTz9F7969G/36uqoIfwVmx+v8fEFtiB7my9Cjk8jLy8Obb76Jb7/9Fq+88go++uijOv9PN1SLhR65ublYt24dgoODMWrUKHz88cdQqVQtcehOI1ilgLqnGz+l6pg0v89HjhyJjz/+GF5eXnKXRdTuvffee/j0009x9OhRDB06VO5ySC78BbRLEEJg0aJF2LlzJ6ZNmwZLS0uYmZnBwMAAVlZWAABzc3MYGxtrBQjqkEHzQlV90am+YNUNKzSDDOoaNAMVzb9rjurR/Ls6VNMMWdSjg9ThWkFBASorK6Vt1cdVhzDqYEcdzOkLf+7FwMAAQgh069YNFhYWqKiowA8//IDZs2e3yPvSdaQgWOWMwGg/hIsQaP8oiYC/KgnL5Q49dD8AgBJByVHgpV/T7N+/H0899RR69eqFn376CW5ubo0/SHPXvK2urhZfffWV6Nmzp3BxcRG//PJLcw/Z5pKDlAKAgF94658s3E8AEMqg5NY/VwtSv0e6b5H03qlvyiAhyyurfV/b4ksohBCpqanC19dXGBgYiMWLF4sbN260zYmJOqAjR44IIyMj8dNPP8ldCsmtjf+vJvkUFhaKYcOGiYULF8pdClGruX79uvbvwfXcFAqFMDY2FgqFQhgZGQlnZ2cRGRkpd/kdVrjfva47woWfvq+F5g+f5CChrOe5IOWdx/3CtY91z2u4cD8B+Ik7R0uWjseffU2Xk5MjHnnkEWFhYSF+++23Ru/frNAjNTVVTJ06VfTo0UN8+umnory8vDmHk436H47WN3Fr/WJW+w+s44Qe6n+omv94NR9Xijsvpb5t20rtf0ptGLxER0cLDw8PYWtrK8LCwtrorEQdR0FBgRg4cKB48cUX5S6F2oMOGvxT05w+fVqYmZmJzZs3y10KUatIT0+vN+gwMTERRkZGwsTERMyaNUs8+eSTwsjISCxfvlxUVlbKXXrHphtY1HftUd/1nO7PIvXxNDa888HunWOrH6v/Z1g910J6jk+NV11dLdasWSMMDQ3F+vXrG7Vvk0OPn3/+WVhbWwsvLy9x4cKFph6m/WLoIYRQ/+PW8x9Jfb+4yv76aoOPNvxPpaKiQnz44YfCxMRELFmyRBQWFrbZuYnauxUrVoiBAweKoqIiuUshmWl+cnbXX1KpU3n//fdF3759RW5urtylELW4c+fOaf2/ZmpqKgAIGxsb8fzzz4udO3eKkpISsX79emFkZCS+++47uUvuRPSN5tD5uaL3ek7/h6Q1H4Jr7K93X30f+up7nqFHa/rvf/8rTExMxF//+tcG79PoSZAVFRV4+eWX8fjjj2PFihU4fPgwXFxcGnuYziclGCqFAv4RchfSkiKwPjAayqDl0J0Gl5IUDwBwd2lvk9N8sDxIeY+lF1uWkZERVqxYgSNHjiAyMhLjxo1DYmJi25ycqB1LSkrChg0b8Mknn0jz86nrCogSEELzpjsXmzqj119/HRYWFvjb3/4mdylELU6zgauzszPeeOMNHD9+HDdv3sTXX3+NOXPm4IsvvsDbb7+Nn376CU8//bR8xXY6PggRAkKEw096LBSzFf646+VYShLiASh952g1QXV2UwIIxba77uyEOb5KANFISNb/fM3POu2fbym7wmpWR+O67C3C19cX27Ztw/r167FmzZoG7dOo0CM3NxezZs3Cr7/+igMHDmDlypVQKBRNqbVxagMFaQ1mjWQhJVilcT8Fwao726mCU+o8ptAJJupuX7vmc22b+NDZdc+pKcK/9nmtZjUNfVmqeuuq97UrVFoX85rHUElPaK5bfWd77W0j7rz2etazTglei1Ao4TunbrDh5OIOAAidrfMfS3ICojX20Xx//SO019NWab6QCH+tx7Xfm9pz6LwXqnpSDac5vlAiGmG72naV7nHjxuHUqVMYMmQIlEolDhw40KbnJ2pv3nnnHahUKixYsEDuUohIJqampvjkXAZvCQAAIABJREFUk0/w5Zdf4sqVK3KXQ9SiLC0tERQUhLS0NCQlJWHt2rUYO3asdH20ZcsWvPnmm/jhhx/w2GOPyVxtZ6UbftwjuEhOQDSA6EBnresw58DGXcnFJzXsOqNmWXYgKJkNvFuSj48PtmzZgvfffx/ffffdvXdo6JCQjIwMMWzYMOHu7i4uXrzY+HEozVY7XEhrKJL+IUThfuohR3X3qRm6pDMkSd9UjUZOb6mZBlLfUCetDaU5aHfOpx6epX9IlmZdehuK1jPV5G6vtebxes6rtX/9w4+1mpgqg0Ry7ftdf7PTe8yJk2rTM8dOqRRK6et4r6FlbT/FRVNlZaUIDAwUJiYm7PNBXVZ6erowMjIS+/btk7sUImoHRo0aJZYtWyZ3GURtJiEhQXTv3l2sW7dO7lI6l+Qgoaznd/w610n6rucaOhW/nmvB+hZ3qK+WjtLSoKP64osvhImJiYiNjb3rdg0a6ZGZmYkHHngANjY2iIyMxMCBAxsXxbSI2uFE0WGQPsBP2YWwaEA70YvAtnhf1Aw0SEZCNIDoBKhHIPnM80OdIUnOblC2wSvQpL1kbe2UDMTjTmgYAf/ZoYAyCJs01jdyCtiEIKXOCIt66q8ZplXnQSgBKIM2IcBJnYzqG2KcgqR4AEo3ONfzGpwCohCuHk8WHQhnRc3yUbojt9SjQvzC75xH/TqiA5feGbki1abx3jjNQc0oMnesktbidkLAKj1fxzsvEm5KAPFJekewtDZDQ0Ns2LAB77//Pp588kmEhYXJUAWRvIKDg+Hh4YFp06bJXUqb8dczck/fY9Q4rf2+1h3xSa1h2bJl+Prrr1FQUCB3KUStrqKiAosXL8a0adOwfPlyucvpfO46jV0Jt/ouXgDAyQXuAKLDdtW9Tojwv8fPgRTsCosGUPd6R3ObYJUCS7EJQgiN6z1qDS+99BIee+wxLFq0SGu6ma57hh4FBQWYNWsWevbsiYiICGl9dTnoTltI2ZUA3+SaoUyh6tQjYhvipTla2hf1Ef53pq20e7XzzeDuAu1/Kk6oyRA0AxIZ1E412TbvzvzsmgAkFLMb9EvovebEtQCNsEsOb7zxBtatW4fFixfj999/l7ESorZVXV2NsLAw+Pn53XvjTiRECCQHKe/5GDVOa7+vAVECIrxrfa/KwdfXFwYGBti1a5fcpRC1ui+++AKXLl3CN9980zatALqcaAQ6615vqHsRboJuzqA9FaX2w+boQDhrHiAlGKq1blofNgNA6No7bQBSgpciMBp6+x2qa/BXOCMwuu70GX1tCqhlfP755ygoKMDHH39c7zZ3DT2qq6vx5JNPorS0FDt27IClpWWLF9kotZ/61yRzKdiV4IY5Tj6YV5N6IAJAxLZ47R4UGn0gts3rQL/Y1M43U+qJKmtGcLRiWHBPKQheGohoZRCWa/yL9wm58/5q/gdxLw2dE9cRLVu2DAEBAVi4cCGSkpLkLoeoTRw9ehTXr1/H3Llz5S6lzdWE8/d+rE3U9kpqtREmrX18Da3+vsow4rOrMTU1xUMPPYSff/5Z7lKIWlV+fj7Wrl2LVatWwdbWVu5yOidlEIL8NHovKhRQKGYD4TojK3zmwQ8aAURtH0OngCiI5CAoQ2ff2X8psEkaVa5xKoTBWaPvh5/uOUh21tbWePfdd/Hxxx8jOztb7zZ3DT2Cg4Nx+PBh7NixAz179myVIhtHY4pLxC4kuNWM6KiZshKKbRGaU1tQE3g411ycJ4sO1jym9hewaD3JRnJCNO45dKtV1U4bqjMKBYDPcgTVFN7gURattgLMXabmtKV169ZBqVTiySefREVFhdzlELW63bt3Y8KECbCzs5O7FCJqR+bNm4c9e/agurpa7lKI7ik9PR0bN25EXl5eo/b717/+BSMjI7z88sutVFkX5xSAqKgABITorgim71pPPeq/9qYZajgFIKq+5zS4r4q6xznucr46t6g6o1CoZSxduhS2trbYuHGj3ufrDT2Sk5Pxl7/8BRs2bGhXS9JKU1zWJsBNnW7Upniha9cCmssPqUdL6CxJ1CHUzjer25dC3WtDI9xpnQJqptHoDS9qe2bUjq7RVhuI3DNwaMicuGbSF8rIwMDAAN/+P3v3HhdVnf8P/DXc7xe5o4IiFwUviIgKiJimgaa2XWy1sNYW2rKwdrtuW23Wt7ZtC3fd/YXbRWtrS2uzEiglBQQs5SLKRQFRUFEucpvhPsPn98dwjnOFAWY4XN7Px2MeMDPn8j5nYOZ83vP5fN4ffoiamhq8+eabQodDyJAUFRUNeZ38/HwsWbLEANEQQsazsLAwiMVi6vlIxoX6+nps374dLi4uuPPOO3HgwAF0dnYOut6+ffsQFxcHMzOzUYiSEALI51T8zW9+o7WSi9akxwsvvIBly5bhN7/5jcGCGxZu8hkEKjT6+4e45OJWIkTBrd4S/ZODqupPjmii69ALee8L3cukaurBoTxkJQbJqfFq483SEuTjxOJfUsxU9p+TnX+9lYSo3I1tO3OhNgxmgGNVJR9Go2nuEG4i0b2IVSl3m5YQi70IR9J+9WyprmPiNJ8bZZXlxQM8KZ/gVtPQIKG4ubnh3Xffxdtvv43r168LHQ4hOlu2bBm8vb3xpz/9CcXFA/zfKSgsLMTChQsNHJmBKJTPVi9XPnAJ9BEbUonygcqO61B6XWspeNVjlE+arVRGPOIOrBpCaXd5SAOd14HiGT6dS6ar0Ec5eaXjTUhTO36dtqm2kPIxDFRyfqzy8vKCs7MzCgoKhA6FEJ1JpVKkpaVh69atmDJlCrZs2YK0tDRIpVK1ZZuampCfn4+77rpLgEiJIUzkYfgTzV133YXy8nJUV1erP6mppEtBQQEzMjJiv/zyy4jLyBhCaryG8j8VSQolTZWXBVdWFfEslS8PKy+zmqZYdlWpzKnCclAtlatt+7dumsoYVajuS6HMq+LjSsemUOL21jFoDERt26kK+wtPqlDf/2Aldgcr6aQWm5bzxJXUDQ/Xfo40xF+h+hr0r6N2zlVOts7lg0eZTCZj8+bNY4mJiUKHQojOLCwsGABmZmbGALAZM2awP//5z+z8+fMal+/u7mYAWE5OzihHqgeq5b+V3gN1LIHev46m8ngDlrcbYolyXcqOay29ruU4ld5LNcRzqxz8INsf7NhUP1t0iWeY51XnkumGKCev+BnJP8F95g+yTbVzIF9PbZ9ark3GsiVLlrA333xT6DAIGdTPP/+s8Rrf1NSUmZiYMBsbG7Z161Z29OhR1tfXxxhjLC0tjVlaWrLu7m6Boycjodo20/o5S8aUvr4+5uTkxP773/+qPacx6fHYY4+x6OhogwdGxj75hdwI/9F1vTDWi/6L1NHZ2ZDt27ePOTo6ss7OTqFDIUQnlpaWahd8XCJk1qxZ7JVXXmEXLlzgl79x4wYDwEpLSwWMejj63zsUG5FK710aGsCa3tuG1TjXsG/5iuoN5MGS0Uqb1fTeq3lf8gSO8nu9UlInNV5r8mTgt1sdz+tg8YwwmaS8DHdeFZI4Ws6rehJ9CK+Vls8jXbepdA40HmsFSwoffxfid9xxB3v22WeFDoOQQWlLeqgmQIyMjJiLiwt78skn2bPPPsv8/PyEDp2QSSs0NJT99a9/VXtcbXhLX18fvvzyS2zbtk29WwiZdHwT9yMpfC9i+7s4j21pSBDFYm94EirG6Ky199xzD3p7e5GWNvbPJiGAfE4aVV1dXQCAixcv4q233kJAQAD8/Pzw6quvoqSkBABga2s7qnGOWNoh7IXKHFAxyQqTlhmwBPpolijv35fqXFfy4Yx7cUjhrSkmORXx/WUBRYc2DW8y8MHO6xDi0Z8RlEw3xGulyznor14nH0rEDaXxRWJOspayiWOXvb09jh49qqGUI93oNrZuS5cuHfTvube3F319fWhoaMDf//53vP3227h69Spyc3UdTE4I0SdHR0c0NzerPW6i+kBxcTFu3ryJ22+/fVQCI2OdLxJzGNbtjoCfSIT41OFXwSkurwRiDDS1aFoCRLF7EZ/KwMbwFaC1tTUiIyNx4sQJGu85yjo6OtDd3a31eU1vkJyurq4BJy9rbW3VWo2gt7cXEolE67pisVjjuGAAkMlkaGtr07pue3s7enp6ND7HGBtwxvnOzk4+eaFJS0sLGGNaY+Nw57SyshK7du0CYwwA8Omnn+L555+HSCQacP1xhasIBsjfazYl6CfxoWuJcn28fXLzOu30g2jnYAvL55baq6/kzojj0b8hfy4Z4rXS6Rz4IjGnAojww85ceSJqJ4DwpIpxVzpRIpEgJCQEb7/9ttChEDKg8+fP44knnhh0OXNzc3R3d2PhwoXw8/NDYWEhwsOpCDYhQmhra4OdnZ3a42pJj8LCQkybNg1Tp04dlcDI+OCbmAOWOPT1dkeIsLM/2Z270w+infFIZQb4ZiomGYwl63urBhEWFoajR48iPz9/zDaIB2vkcw1iTXp6etDe3q513ba2NshkMo3PSaVSiMViretKJBKtZX/7+vrQ2tqqdd3RZmxsrPFNl2Ntba11ZneRSAQHBwet61paWsLCwkLr8w4ODlqTDebm5rCysoKlpSUsLS3Vnrezs4OxsTF/X9dvq8zMzCCVSrFixQpkZGRg2bJlEzPhEZ6ECq6snb56ISiVKFduwOq9RHn/vqBTY7kSuw8FIike2Lk3FgmbDFD6fUjx6N+QS6Yb4rXS+RzIv4RIBG79Pe70Q4K/AV4XA2pubsayZcuwevVqoUMhZEAD9VjkEh0+Pj548MEHsXXrVvj5+eGbb77Bjz/+CMbYxPoMBJAgEoFLgXNfgmp6jGig8KUJMD4T1uNFbW0tXF1d1R5XS3rU19fD09NzVIIiEx9/gUZ4Hh4euHTpEkJDQ3Vex8LCQmMDdbDnxuq6YzWukR6To6Oj1ufGq+TkZHR0dGh8zsLCAl1dXfD19cUjjzyCbdu2wd3dHfb29mhqahrlSEeIa8weSEFlomL1qUrsjvgr/F+C4UqgcxW4istRiRilfeu9RHn/vvaqHSeAtARElD/DX4ilJWwDnslBoq8/SvfGYm9sAjYNNWk92HnN2aRzPPozgpLphnitdHlN/P+qfC58E5HD/JEgih3izoR37do1uLm5CR0GIUPGJfednZ1x//33495770VkZKTSMmFhYWhtbUVZWRkCAwMFitQwkhnDM7sj4Lczd8DHiAa+ichhiajU87nitxefCkYZJ1y7dg1XrlxBWFiY+pOqk3y88sorNIkpIQb06aefsmnTpgkdBiE6mTJlisZJ21xdXdlzzz2nsYpLVFQUe+mllwSIdmT4Sh8Ks0WmxvdPHslVTdFQ4UtTdRWlCTE1PaZKbfu3KlUNuv1Btql5ck4N1VEUJtKsSArXeAyDVXjRZMDzqmM8Iz6vKsemtp6mijFMS1UWXV8rLROUatrmoOdA07FWJLHwcVZRoLGxkQFgeXl5QodCyKC4iUyNjIyYvb09e+yxx1h2djZfqUUbHx8f9s4774xSlKNsuJNKE7mhTEauSMvE4dxnz5C3N0H9+9//Zi4uLkwmk6k9p5b0eO+991hwcPCoBEbIZLR79242f/58ocMgRCcuLi5MJBIxY2NjZmtryxISEga96Nu5cye74447RjFK/VEt7a3cxh96CXS1UuED11cdsET5kMuOD1R6XXVf/HPKZdSVK9eoxqVbaffBzuvA8Wg47qGcVx1KphuknLxqGXbEs9ShblPl9YoPV339x1fCgzHGjhw5wkxNTVlXV5fQoRAyqKKiIhYXF8fS0tJYb2+vzuu98sorLDAw0ICRCYiSHiOj56QHUbZ06VK2c+dOjc+JGFMemH/w4EEkJCTg5s2bE24sGiFjwdNPP43z588jNTVV6FAIGZSfnx/mzp2Lhx56CDExMVrnIVH03XffYfPmzaivrx9/VVzIxKIwyTX1/BVeYmIizp07h2PHjgkdCiEGc+XKFfj5+eGLL77Apk2bhA5Hv/rnppir+J6q6TGiWf+5GvI8VvRZNqhjx45hzZo1KC4uxuzZs9WeV6tFuHTpUjQ3N+P8+fOjEiBRlYYE1bJZERGIiNgNfVUsHEvSEhSPc2Ieo6qTJ09iyZIlQodBiE7Onj2Lb775Bhs3btQp4QEAa9euhZmZGX744QcDR0cIGS8YY/jmm29wzz33CB0KIQY1ffp0/O53v8Pzzz8/YNU4QaQlKLcxEhRn5K7E7gjlNkiC3sqG67jtAePT4fnK3YhQakdxJb7V14/YXYnK3REKyybI5ydX2UbEbg2tk8H2o225bQeGeG7624X9VdTkZcvlx624jlqMQzgPooQ0tfOq/tpoap+OnXabTCbDs88+i23btmlMeABQn9ODMcb8/PzY//3f/xmu78lko2uXJE1dnjSMR54oXZzkXcVvdc9NjR+k6/cEcPXqVWZsbMxOnDghdCiEGNTWrVvZ+vXrhQ6DTHZDmQOFGFR6ejozMTFhtbW1QodCiME1NjYyd3d39swzzwgdyi2q74dK7Y7+4XcK7Q35dbrKMMphDW/RcdsDxjeM59kg8zJp2BbCwxXmk+KGJA4S5yD7ubXcrSGOao/peG7UzrGO811pjE9xSCX/BBej4vBJ+WNq2xtgSOto27VrF3N0dGTXrl3TuozGpMeuXbuYv7+/xklAyDDomKRIjdc8JlrtD2tCJD36x4KrToo3hv6BDOH1119nvr6+g06CRch4d+rUKSYSiVhxcbHQoZBJSnX+jPE4B8ZEsnbtWvbrX/9a6DAIGTWpqanM2NiYpaaOhXceDRMrK7UnuDmaFN4nNbU3hpX00GXbOsY3lOflwak34jXOq6Gpsa9jnBrX17Kc2r51PO/a2n7atqfLedDUFmNcgkQh6aLx9a1gSeFj4zM1MzOTmZiYsAMHDgy4nNrwFgDYvn07rl69ii+//HIEHU3I0PSXu8stRYXKM76JLyFeiJCGo787lc7d4YrLlbtGzfUfWjlIXbuXjQFisRhJSUl4/PHHab4cMuEtXrwYUVFRePvtt4UOhUxSiTkMjCnehlhul+jNmTNncOTIEfz+978XOhRC9Kqurg6FhYUan4uJicHzzz+PzZs348yZM6McmYq0Q9gLlbLrMclgjJsjIgbJCu+TaQm3hlSMnA7bHiy+wZ6vLEcxoKEd4Qv/uQBQjHJ9tA903Y+meDXS83k3xHnwXYf7wrmhNVw7yxeJOcJ/pl64cAF33XUXHnvsMdx7770DLqsx6eHh4YEnnngCf/rTn9DR0WGQIIdLcexVxG6F8UyK44pUG8IKLXDF8U8Jacrjk3Qas6XWmh/eOCx13B/jXsSqjZGKQXJOInx12Z7ejn1oY7f4uTn8dkK36tMxeCYpHMjdiW27K+X7iwVShzI7T1oCRH6leIm/oK1AUngudvrpcwyi/rz11luwtLTEo48+KnQohIyKl19+GZ999hny8/OFDoUQIqCnnnoK69atw6JFi4QOhRC9qq6uRkhICNzd3bFjxw4cPXoUPT09/PO7du3Chg0bEBMTg5KSEgEj1YFCG+LQJgaWqsevXA25bQCoKEUugPBAP7Wn/ALDAeSiVPVbZQPup7K8WPdt6vPcGOQ8+CIxpwJJ4QAgb2dpbTePosrKSqxZswbLly/Hu+++O+jyGpMeAPDCCy+gp6cHL7zwgl4DHCnfxBz+jyF35+vA/lR5Lwiuh0RaAkT9s+IyxsAqkhC+N5Zv/CfmMFTIXzXsjT2ETf0N5oqkcOTu9FN+AQfZljzh4YedSEJF/3ZS44G9sVwWrD971x9vfGp/41xLwz7mmSTI/552wk9xQp1bSwy8Pb0deyV2R8SimNsOu7WeNjHJisuFQ8P/mhrfxP2Q5z38IBIdwibFLKdSwkX1PPTH+LpqJtQXifvl53DvobGV9Th9+jTefvttvPfee7CwsBA6HEJGxW233Ya77roLTzzxBJhyoTBCyCTxxRdf4OTJk/jb3/4mdCiE6J2VlRUAeY+PvXv34o477oCDgwPuvvtufP7552hpacHHH3+M5cuXY+XKlVp7hQiuv6pIbri8TaPXCiGG3DbHLxDhAHI1tOgrSnOha9tEX/vxlX+TPTh9nxuDnQffW70nK+RtrdydfoJ9yVxaWooVK1Zg7ty5+OKLL2BsbDzoOlqTHvb29vjoo4/wz3/+E4cOHdJroCPW/4KGJ+1Hoq9it6A0JMTuBcKTsJ8rA+SbiJfiAew9xDecuT/E+NRb3XJuNcC39ScsdNlWBUpzoTQkJWZTPIadTfRNRA5LVRjKshexWhv9qvR47JUpOJALzPW/1THKN3E/kqA+9GZE0v6KnRq6hcQkqyZ2hO8+NRJNTU3YsmUL7r//ftx9991Ch0PIqHr33Xdx9uxZ7NmzR+hQ9E+pZ90A79O6LjcAxZ53Wi8ydJlxnujNrXM9dodVCq2+vh5PPfUUnn32Wfj7+wsdDiF6xyU9AKC3txd9fX3o7OzEt99+i4cffhjOzs6IiIjAwoULER4ejqioKHzzzTejHyjXGD6QotJruxK7IxKQxvUQGHQ4xjDosu3B4hvseV9/yEdvlKs9X14MIPw+rNPHgem6n5hNiNcYrwp9n3dDnIe0BOXrCbX26uj68ccfERERgWXLluGbb77R/cvkwSYH2bVrF7O2tmYFBQXDmlzEIDROQKP9cbUZa7VMBqO0nK7bUiCfbRe6Tz4zIG5iGw0TsA0wsZBejl1hdmG12YMHoTb5zYDL9R8TN4uy6qSmw5ipdaDXRwjd3d1s5cqVbMGCBUwsFgsdDiGC+OCDD5i5ufnY+hwZqYokFt7/XqdxpvUBltuxI1z9PU+nXer2/sYtRxVLDG/A136S6+vrY+vXr2eLFi1i3d3dQodDiEFcv35dZcJkzTczMzMGgE2ZMoWJRCK2fft21tPTM6qxcp8Nip89qfH9nylq1+K32iEDVyTR8hhTX2ewbQ8Ynw7Pa2pPcG0zjVVLlB/UOJHpgNVfBtmP+mexhuotIznv2h7X9TxomfRUW9tRaR8VSSx8lCcHl8lk7C9/+QszMTFhzz///JALrgya9Ojr62MPPvggc3FxYWfPnh12oHqlLemhUIJI003Xhn+4/OpUt20plPtRfNMYedKDX1n9j3+Afejl2OWPqM18r8sFtG5JD/XZgpXfyCpYUvjQLyJ1TbiMlu7ubrZx40bm6enJqqurhQ6HEEHdf//9LCAggDU3Nwsdil7oWmJb03LcxceQkxKDzpCvvBwlPQxvrH3ujCVvvvkmMzc3Z7t27WLJycns008/ZQcOHGBfffUVO3r0KDt69CjLzc1leXl5rLCwkF28eJFdvHiR1dXVsaamJtbW1ib0IZBxrqenhzU1NbGmpiZ248YNdvHiRVZZWcny8vJYXl4eS09PZ0ePHmVff/01O3DgAPvoo49YcnIyS0pKYm+99Rb785//zJ577jn29NNPs/j4eLZ9+3Z27733snvvvZetXr2arV69moWEhOiU9FC9GRsbs9mzZ4/69SF/va2hYa345a288a/wBWx4EktTWRfxqWrb0/a5ONi2K3SIT5fnlcqw8vtSCkQ53vAkVqH2RbN8u8oxqxzbYPvRGG84S0pVXE++jm7nRiVGLa/HsM8D4lmqtrZfRRKLDw/XsPzoqa2tZbfffjuztbVln3/++bC2YYJBiEQifPTRR9i6dStWrVqFH374ASEhIYOtJoz+rk9IqkBO4vA7Cc3199VtW4rjsHIS5d2Shju2qXI3Iv7qjxy1wVzyCT/3ahoHokifxw6AG7uVyMXmt1M+dstfD+PN+mc0VuSbuB9JB/ywc28sIorDgfv2I0fHw6jcHQG/nbkIT6oAY3rvlDcsnZ2d2Lx5M/Lz83Hs2DF4eXkJHRIhgnr//fcRERGBu+++G2lpaTAzMxM6pBFIw6G9wOB9OzUvF5PMwJINExkhY8HBgwfx0ksvwd/fH1988QU6OzsBAM3NzQDkn5FdXV06b8/W1hYmJiYwNTWFjY0NAPmwAnNzc34ZBwcHvjKa4nIAYG1trfSe4+joyP9uZmYGa2tr/r6NjQ1MTU3VYrCwsIClpeWA8WmiuC9d2dnZ6TRGfahaWlp0nl+pvb1daUJOVVKpFGKxWOmx7u5utQIIml5riUSC3t5epcdaW1vR19cHAOjr60NraysAQCaToa2tTe13xf0r/t7b2wuJRKLTMQK3/laMjY1hZ2cHkUgEBwcHALf+prjX19raGo6OjrC0tISPjw/MzMxgaWmJgoKCAfchEolgamoKxhg2bNiARx99FLNnz8YDDzyAefPm4bXXXsMTTzwBIyOtsw7ojW9iDlii5uc0fTbFMIZbDyVqWDdG6/aGtu3B49PlefnQiwEWiEkG0/ABnKwhFsQM8Fk92H74xdTjTVR9QKdzE6MhRk2vh47xaTkPMVzbT2U/yTmJ6udnlBw8eBCPPfYYZs6ciYKCAvj6Dq+tN2jSAwBMTEzw2Wef4eGHH8aKFSvw+eef48477xzWDg2qfxzT3gMpqExMVB4blZaAiPJnBkgIVCLlQC6AeGyKAQAdtuWv53FYe1/H7mdioDnEQSae0eexqy7vm4gc5o8EUeyQD0kjblxecTkqEdMfqy8Sc1JRKorF3txcxL+kyxmVTyR74L6xk+wA5JNZbdy4EXV1dTh+/DiNYyYE8nmiUlJSsGzZMvz2t7/Fvn37qHQzIRNQdnY24uLi8Oabb+KZZ54ZcFnGGFpaWgAAHR0d6O7uVmrwcg1vxcauYoNZ8XfFbQHqDXCxWAypVAoAuHnzJr8PAOjq6uITM4qxaNLW1gaZTDbgsUx0mhJAqkkoQHMyyN7eXqlxr5hk4NjZ2fHJIsXlFX9XTHIp/q6YZOJ+V9wHF+dASayhevnll/m/LUXm5ubo7u5GUFAQHnnkEcTFxSnFd+zYMezZswd//OMfcfDgQfzjH//AwoUL9RITIeP9pMl7AAAgAElEQVRdSUkJEhMTkZubi1dffRVPP/201uSyTobSLaSvr4+98sorzMTEhL3++utDHkujNwOMHdM03otVJLFwxfFKXJceDd2pFLc56LZGOg5LOXDlYTK3Vmbxqutq2Z7ejn0EY7d067at0H1KdR4PHbrI9S+s1hVN+SZMd+OTJ08yb29vFhYWxm7cuDH6ARAyxuXn5zNbW1uWkJDA+vr6hA5HnVqXUOX3ErXurirvp4Mtt0Oh66i2eam0vgdqG96iul54uG7DW7S85yp2xw1PSr31fq14nNpiHeAYKpLCFe4rd6MdaLhqeFKFShfh/s8ilX1pPN6Bzqke9sEPb0kdWSyDn3MNn3ka/u6EdvLkSWZvb8927NghdChjiuIwi5HeuGFAut7q6+t13nZHR4fQp2pcsrGx4f8vRSIRMzU1ZZaWluyRRx5h+fn5g65fXV3NNm3axIyMjNiWLVvYxYsXRyFqQsammpoa9vDDDzNjY2MWExPDKisr9bLdISU9OAcPHmT29vbs9ttvH/WGndrYMU2NW7ULQJULA65RHz7IuDAdtjXccVhqFyr9yYkkDRfK6nENsD19HPswxm5pvMDXdk61raPtolnjhd3YSnrIZDL29ttvM1NTU7Z9+3a6cCBkAHl5eWzKlCls+/btwiXPNdGQ8NU8eaj6vERaNqh5OV0mgtM00ZqmpIfatjRMlKbLsarOA8InBMJZUgX3fqs8+bT2WPtjUHrv1jxJXGr8AO/VKkkJpX2Fhysk9Lltq2xLl3M6wn3w1ySDfIkytFhUz7l832p/l2Ms6ZGTk8Ps7OzYI488Mrb+rwkxMBcXF2ZsbMwAsEWLFrGPP/6Ytbe3D3k7P//8M1uxYgUzNTVl8fHx7Pr16waIlpCx6ebNm+y5555jlpaWbPHixeynn37S6/aHlfRgjLHKykoWGhrKnJyc2KeffqrPmAxvRBOLjnOT+dgN5MKFCywyMpLZ2dmx//znP0KHQ8i48MsvvzAHBwd2//33s66uLqHDYdpmMdfcWB9h0kNtolHN+5YnhhX2q5b00BLzoBOZalhP9bNB6zZ0i1Vtgk+NvRlTWfxADXeNMWhOnqh/tg3tnA5vH9omMlVdfySxMM3JLlbBksJHdyK5gaSkpDBbW1v2u9/9bmz24CLEgMLCwtiTTz7JiouL9bK9b7/9lgUFBTFbW1v28ssvs/r6er1sl5Cx6ObNm+z1119nDg4OzN/fnx04cMAgnyPDnjFn1qxZOHnyJJ5++mk88sgjWLduHc6fPz/czREy7nR0dGDXrl0IDg6GtbU1zp07h61btwodFiHjQlhYGDIyMpCdnY1Vq1ahsbFR2IAqy1EMAHP9VeZo8oW/vOg9yis1rKfHfavOD+UXGA5gLw5pmyC7f1LoIc8rpWm9mGQwpsNE1TrG6rvuPoQjFwdS5CetMqUU91WkIh7AXm6htEMo1tecWMOM0zB8se4+hf2MNBbfdbgvHNgbK4JIFIHdlfJ9JOYkY6TziuvDP//5T2zcuBGJiYn45z//SXP1kEknNzcXu3fvRlBQkF62t2HDBhQVFWH37t347LPP4OXlhe3bt+Ps2bN62T4hY0FZWRkeffRRTJ8+HXv37sWbb76J4uJi3HvvvQb5HBnRNMEmJiZ48cUXUVBQgN7eXsybNw+PPfYY6uvr9RWfQRUb7Ap27JvMxz5SfX192LdvH/z9/fH+++/j/fffR1paGlVoIWSIFixYgF9++QWdnZ1YtmwZzp07J1wwFf0TU2uYMVreOM1FaYVh95270w8ikYi/+Q1StauyvNhAAQ1A11j7G+q5B1JQiUqklAZinW8MNsmzHkgDkHaoGPetM9Ak1MM8p2MzFl8k5lQgKRwAcrHTT75+xG5hP8d7enrwxBNP4Omnn8YHH3yAXbt2UcKDTEqGqLRjbGyMhx9+GOXl5fj+++9RX1+P4OBgREZG4uDBgxon0yVkrGOMIT09HXfeeSeCgoKQl5eH//f//h8uXryIRx99VGPlLH3RS22kwMBAHDlyBGlpacjJyYGPjw9effVVpZmwx4rdESKIYuUFU+UXIAnDrjI73kzmY9eXn376CaGhoXj88cfxwAMP4Pz584iLi6MLPUKGydPTE5mZmQgODsbSpUuxb98+YQLhqkppyGxUlOZi0Apaeti3vOw2U7tp633hK++CMrp0jrW/t0PuAaSkpaA0UN7LIUae9cChtDQcKr4Phsp5DPecjt1Y5GXkGWNgFUnyv9WdfkgQ6EO8pqYGUVFROHjwII4cOYJt27YJEwghE5yRkRFWr16N77//HoWFhfD398eDDz6IgIAAvPXWW6ipqRE6REIGVVtbi7/97W+YM2cO1q1bB3t7e5w6dQp5eXmIi4sbWVUWHem1IPTq1atRUFCA9957D8nJyQgICMCePXvQ3t6uz92MCH/RwN/GRvfQ0TCZj32kjh8/jjvuuANr167FokWLUFlZibfeegu2trZCh0bImFdVVYWysjKtnwU2NjY4ePAg3nzzTSQkJOA3v/kNJBLJ6AbZX/YbxeVQ/v68EuXysQmGa6D371veK0JFWoL2b/RjNiFe23oD4RI8autVYnfEIMnwIcTKD3F5vRSB3Mnrj3nv668DhhraMsQ49U+lDPxIY1FdxjcROUw+VEgI3333HUJCQmBhYYHCwkKsWLFCoEgImVwWLFiAjz76CDU1NXjooYfw4YcfYubMmYiOjsaHH344aUomk/FBLBZj//79uP322+Hl5YU9e/Zg8+bNuHTpEv7zn/8gNDR0dAPS+ywh/cRiMXvttdeYq6srmzJlCnvxxRdpFmIyrvT29rLPP/+cLVq0iBkbG7N7772XnT17VuiwCBl3/vWvf/EVMqysrJiPjw+Ljo5mDz/8MHv55ZdZcnIyO3z4MCsqKmI//vgj8/HxYTNnzmQZGRmjG6haGfJbVaYMXb1lKCXHNa031OotmvaXGq9wnCMtDa94/Bon8NShwpamCidaJhnVVGVHpzj1tQ8N1VuGHIu2cz6CMvL61NLSwh566CFmbGzM/vjHPzKpVDqKeyeEaHLy5Em2Y8cO5uzszCwsLNg999zDDh06xLq7u4UOjUxCvb29LCUlhf36179mVlZWzNHRkSUkJLATJ04IPsm1wZIenK6uLrZ//34WGBjIzMzM2IMPPsjOnTtn6N0SMmxtbW0sKSmJeXt7MxsbGxYfH8/Onz8vdFiEjFtnz57VWFrayMiImZubM0tLS77cHwBmamrKrK2tmUgkYkuWLGE3b94cvWBVS2ZrqeCheNOY+9CynFrZdQ0lafnnNDSkNa2n/Fw4S0pV3I72hrHqNm9VDddDaXj+NGipRjJYuVXV8xeexCo0lCqPTx2g/PlgcephHxVJ4Sw8KZVPNGk9X4PEMuA5H0YZeX1LS0tj06dPZwEBAezkyZOjuGdCiC6kUik7evQoe/DBB5mNjQ2zsrJi69evZ8nJyezatWtCh0cmsJs3b7IDBw6wBx98kDk6OjJzc3O2fv16tn///mGVbjYUEWOMDaVnyHD19fUhJSUFf/vb35CVlYXo6Gg89NBD+NWvfgUbG5vRCIGQAeXk5GD//v348ssvYW1tjSeffBIJCQlwdHQUOjRCxrW+vj7Y2dnpPNSRm+jxnnvuwcmTJwEASUlJ+NWvfmXIMAkhKq5du4annnoK//vf//Dkk0/ijTfegKWlpdBhEUIGIBaLkZaWhpSUFKSmpqKpqQmLFy/G+vXrsW7dOgQHB9NcdGREzp07h5SUFBw+fBg///wz7O3tsXbtWqxfvx6xsbFwcHAQOkQ1o5b0UJSXl4cPP/wQX375JXp7e3H33Xdj27ZtWLFiBYyM9DrNCCEDqqmpwSeffIJPPvkEFy9exKpVq7Bt2zbce++9MDMzEzo8QiaMNWvWID09HYN95JiamsLPzw/79+9HaGgo2tvbsWvXLrz77rtYtWoV/v73v8PPz1AzihJCAKC3txd///vf8eqrryIwMBD/+te/sGjRIqHDIoQMkUwmwy+//ILDhw8jJSUFZ8+exbRp07BmzRqsWLECUVFRmDFjhtBhkjHu6tWryMjIQFZWFo4cOYLq6moEBgbyibSIiAiDVDHSJ0GSHpyuri589913+OSTT/Djjz9i6tSpiIuLw/3334/AwEChwiITXHNzM77//nvs378fGRkZ8PPzQ1xcHB588EFMnz5d6PAImTCampqQk5OD7OxsFBYW4sSJE+jq6tK4LJdkfO211/CHP/xB7cOzrKwMjz/+OLKzs5GQkICXX34ZLi4uBj8GQiYTxhi++uorvPjii2hqasIbb7yB+Ph4+kKKkAmipqYGKSkpSE9Px4kTJ9DQ0AAvLy8+ARIVFQV/f3+hwyQCq6qqQlZWFjIyMnDixAlUVVXByckJkZGRWL16NdatW4eZM2cKHeaQCJr0UHTjxg189tln2L9/P86dOwdfX19s3LgRGzZsGBfZIzK2Xbp0Cd999x2+++47ZGVlwdbWFvfddx+2bduGZcuWCR0eIRNCTU0NTpw4gezsbGRnZ6O0tBQWFhZYvHgxFixYgH/84x9qPT1EIhGMjIywcuVKfPDBB/D29h5wH9999x2ef/55XLt2Dc8++yx27twJa2trQx4WIZNCZmYmnnvuORQVFWHHjh144YUXMGXKFKHDIoQYCGMMZWVlyMrKQlZWFjIzM1FbWwsPDw9ERUVhyZIlCAkJwcKFC2FnZyd0uMRAJBIJCgsLUVBQgNOnTyMzMxNXr16Fu7s7oqKisHz5ckRHRyMoKGhcD4saM0kPRVwD9fDhw8jMzIStrS1WrVqF9evXY9OmTfSPR3RSUlKCgwcP4vDhwygoKICXlxc/3mzt2rU0fIWQEaqqqkJ2djZycnKQnp6Oqqoq2NnZISwsDBEREYiMjMTy5cthbm6Ozs5O2NnZQSqV8uubmZnB2toaSUlJiIuL03m/UqkUH330EV599VVIpVL8/ve/x+OPP07zQxEyDBkZGXjttdeQmZmJrVu3YteuXYMmHwkhE1NlZSWfBMnPz0dZWRn6+vrg5+eHkJAQhISEYNGiRQgJCRmT8zaQgbW2tvIJjvz8fBQUFKC8vBwikQgBAQFYtGgRli9fjqioKAQEBAgdrl6NyaSHosbGRqSkpOC7777Djz/+CJlMhqVLl2LlypVYuXIlwsLCYG5uLnSYZAwoLy9HRkYGMjIycPz4cdTV1SE0NBQbNmzAhg0bMH/+fKFDJGTckkqlKCoq4pMcx44dw82bN+Hh4YHIyEg+ybFw4UKtXeFDQkJQWFgIIyMjMMYQFxeH9957b9iTBXd2dmLv3r14++230dPTg6eeegqPP/447O3tR3KohEwK6enp2LVrF7Kzs7F582a89NJLNLSYEKKko6MDRUVFfAM5Pz8fpaWlkEql8PHxwYIFCxAQEIA5c+Zg9uzZmD17Nn05PQZIJBKcP38e58+fR1lZGS5cuICzZ8+isrISRkZGmDNnjlICKzg4eMJ/cTTmkx6Kurq6kJGRgWPHjiEjIwMFBQUwMzNDeHg4oqOj+SSIqamp0KGSUXDx4kWlJMe1a9cwbdo0PiG2du1aeHp6Ch0mIeOSRCLBzz//zCc5cnJy0NnZCR8fH6xevRoRERFYvnz5kMZ0PvPMM3jnnXcwY8YMfPzxx4iOjtZLrF1dXfjggw/wl7/8Ba2trdi+fTsSExNpcjZCVPT09ODLL7/Eu+++i+LiYtx///344x//iNmzZwsdGiFknOjq6kJRUREKCgpw7tw5XLhwAefPn0dtbS0AYOrUqZg9ezYCAgIQGBiIgIAAzJo1C9OmTaM2mh719vbi2rVrqKqqwoULF1BWVsYnOq5cuQIAcHNz41+DuXPnIiQkBAsWLICVlZXA0Y++cZX0UNXa2ooTJ07g+PHjyMjIwJkzZ2BpaYmwsDCEhoYiNDQUixcvHncTrRB1ra2tyM/PR15eHvLy8vDzzz/jypUr8PT0xMqVKxEdHY3o6Gj4+voKHSoh49KNGzdw+vRpfuLRU6dOgTGGBQsW8L04brvtNjg5OQ17HykpKTh58iReeuklWFhY6DF6ud7eXr5Bd/bsWfzqV7/Ck08+icjISL3vi5DxpKGhAR9++CH27NkDsViM7du348knn6TEICFEb1pbW1FZWYmqqiqUlJSgtLSU/52bxNzR0RE+Pj7w8fGBh4cHPD09+fuzZs2iITMKurq6UFtbi6qqKlRVVaG2thbXr1/n79fU1PBDhj08PBAUFITAwEAEBQXBx8cH8+bNg5ubm8BHMXaM66SHqubmZmRlZeHnn3/G6dOnkZ+fj5aWFjg5OfEJEC4ZMnXqVKHDJVq0t7ejsLCQT3Dk5eWhvLwcxsbGmDt3LkJDQxEWFjYhx5sRMloU5+PgJh21sbHB0qVL+SRHREQELC0thQ51WI4dO4b33nsPqampCAoKwqOPPooHHniAut2SSSU7Oxvvv/8+vvrqK7i7u2PHjh347W9/S0PACCGjpre3F1evXkVNTQ2qq6tRXV2Nmpoa/lZdXY3Ozk4AgI2NDdzc3ODq6gpnZ2e4uLjAzc0NLi4ucHFxgbOzM9zd3eHi4gJ7e/txNSRDIpGgra0NDQ0NuHHjBhoaGtDY2IjGxkZcv36d/72+vh51dXUQi8UAAAsLC3h7e2P69Onw8vKCl5cXZsyYwf8+ffp0mqdQBxMq6aFJbW0t8vPz+VtOTg6am5v5TCOXEeN+zpw5c1zPTDue9PT0oKKiAqWlpXxGuKSkBBcuXIBMJoOPjw8iIiKwaNEifszZZOyORchIyWQynD9/np9wNCMjAw0NDfDw8MCiRYv4EmQDzccxXl2+fBl79+7FRx99hPb2dmzevBkPPPAAoqKiJtyxEgLIr3u+/PJLfPzxxygpKUFMTAx+97vfISYmhv7mCSFjUn19Pa5cuYLa2lq1pAB3n/u9p6dHaV0HBwdYW1vDxsYGNjY2cHBwgI2NDf+Yg4MDRCKR2vxhg90HgJaWFqWqc9ruNzc3o729HRKJBO3t7RrvKzI1NeWTOFySRzWp4+HhAS8vL+qtoScTPumhSiaT4cKFCzh37hxKS0tRWlqKsrIylJeXo7e3F/b29pgzZw6CgoIwe/ZszJw5E97e3vD29oaLi4vQ4Y87nZ2duHz5Mp/ZraioQElJCcrKylBTUwPGGKZOnYo5c+YgMDCQTz5Nhgl1CDEUrrcU14vjxIkTaG1t5ROJXC+OoKAgoUMdNT09Pfjmm2+wb98+pKenw93dHffffz+2bNmChQsXCh0eISPS0tKCr7/+Gp9//jkyMjLg5eWFrVu34pFHHqEhLISQCaWlpQV1dXWQSCRobm7mEwtcckH1fnt7O3p6esAYQ0tLC78d1fsAlJITXLKEY29vr5Q45u6bmpryyRXV5IumZIybm9uwJ3Anwzfpkh7a9Pb24uLFiygpKcH58+f5HgeXL19GU1MTAMDKygozZszAjBkz4O3tzf/ksnBubm6wtrYW+EhGT29vL591VeyyVl1dzSc66urqAADm5ubw9vbGrFmz+IRSUFAQ5syZQ91sCRmh+vp6/PLLL3yS4/Tp0+jr61Oaj2PlypVwdnYWOtQxoampCV999RU++eQT5ObmYvbs2bjvvvuwdetW+Pn5CR0eITrp7u7GkSNHcPDgQXz99dcwNzfH+vXrERcXh1WrVlGvVUIIIaQfJT10IBaLUV1djUuXLik16LnfGxoa+GWtrKzg6urKd03iuidxv0+ZMoXP+NnZ2cHe3h62traCj8XiMqPcrbW1Fa2trWhoaEB9fT3/k+tuxnU541haWiolhLgbd9/Dw4MuwAjRk9raWn6oSnZ2NsrKymBlZYXg4GC+F8eKFSto/godVFVV4fPPP8d///tflJaWYunSpdiyZQs2bNgAb29vocMjRElXVxeOHz+OAwcO4H//+x/6+vqwadMm/PrXv8aaNWtgYmIidIiEEELImENJDz3o7OxEQ0MDrl+/zicEbty4wScL6urqUFdXh4aGBrS0tPAzGCsyMzPjuz7Z2trCxsZGaQJBOzs7GBsb8/dVu1wp4rpxcdra2iCTyQAAfX19aG1tRVtbG8RiMZ/kUGVkZAQHBwc+WaOavHF3d+fHn1E3LUIMR3E+juzsbGRmZqKmpgZubm5YvHgxn+QICwsTPHk63p05cwafffYZDhw4gJqaGsydOxexsbGIiYlBZGQkNSiJIKqrq5GamorU1FQcO3YMMpkMa9as4ZNzNNcVIYQQMjBKeghAKpVCLBajpaVFqXdFS0sLn4jo7OyEWCzmSxEB8lJQfX19/H3VSXEAeU8Tc3Nz/r6tra3Shbq9vT1MTExgb28POzs7vteJra0tP9bM1taWLqIIEUhHRwcKCgr4JAc3+bLqfByBgYHUe8qAqqqq8P333+Pw4cPIzMyEmZkZVq5ciTvvvBPr1q2jCmDEYGQyGc6cOcP//RUUFMDV1RVr1qzBnXfeibVr11IvLkIIIWQIKOlBCCECamtrw6lTp/gEx4kTJyCVShEQEMAnOFauXInp06cLHeqk1dzcjCNHjiA1NRVpaWlobGxESEgIYmNjsWrVKoSFhY3b0r5kbKioqEBWVhZ++OEHHD16FO3t7Vi2bBliY2MRGxuL+fPnCx0iIYQQMm5R0oMQQkYRNx8Hl+QoLCyEhYUFFi5cyCc5li9fDgcHB6FDJRr09fUhLy8PKSkpSEtLQ0FBAYyNjfnSv8uXL0d4eDicnJyEDpWMUVKpFEVFRXxlpZycHNy4cQPu7u5Ys2YNYmNjsWbNGho2SgghhOgJJT0IIcRA+vr6UFZWplQ69vLly7Czs0NYWBhWr16NiIgILF68WGlYGhk/qDwwGYzqkLXs7Gy0tLTQkDVCCCFklFDSgxBC9ETxG9ycnBz89NNPaGpqgoeHB9+wiYyMREhICDVuJqje3l7k5+cjJycHWVlZyM3NRWNjI6ZNm4bQ0FAEBwcjODgYCxYswIwZM4QOl+iZRCLB2bNncebMGZw5cwaFhYUoKioCYwwLFy7ke3JFRkbC1dVV6HAJIYSQSYGSHoQQMkxtbW38PBwnTpzA6dOnIZVKMW/ePL5hExkZCU9PT6FDJQJhjKGsrAy5ubkoKCjAmTNncO7cOUgkEjg6OmLBggVKiZCgoCCYmpoKHTbRQW1tLZ/c4G4XL14EYwyzZs3iX9clS5Zg6dKlsLGxETpkQgghZFKipAchhOiooaGBLxt74sQJFBUVwcTEBIsXL0ZUVBTfm4MqK5CB9PX1obKyUq3BfP36dZiZmSEoKAhz586Fv78/fH19+RvN8zL6pFIpLl++jMrKSlRWVqKiogJlZWUoKipCfX09LCwsMHfuXD7BERwcjPnz58PW1lbo0AkhhBDSj5IehBCixfXr1/kx+Dk5OSgoKICVlRWCg4MRGRnJz8lBlTuIPtTX1/MJkJKSElRUVKCyshINDQ0AAGdnZ/j6+sLPzw9+fn5KCRGa9HL4ent71RIb3M/q6mr09vbC3NwcPj4+8PPzQ0BAAN9DJyAgQKksPCGEEELGHkp6EEJIv6qqKj7BkZ2djdLSUtja2mLJkiV8giMsLAxmZmZCh0omkdbWVqXGuOLv9fX1AIApU6bA09MTnp6e8PDwgKenJ9zd3TF16lSlnxYWFgIfzeiqq6tDfX09rly5ovTz6tWrqKurw9WrV3H9+nVIpVJYWFhg1qxZSskkLrk0ffp0GBkZCX04hBBCCBkGSnoQQiYl1coqGRkZuHLlCtzd3REaGsr35Fi4cCE1dsiY1dbWhsrKSlRVVaG2thbXr19X+9nU1MQv7+TkBHd3d3h6esLFxQX29vawt7eHg4MDHBwc+PuqNyGHa/T29qK1tRWtra1oaWlBS0sLf1/1dvPmTT6ZUV9fj56eHgCAubm5xiTQ1KlTMX36dPj6+mLatGn0v04IIYRMQJT0IIRMCoNVVuF6clDZSDLRdHV1aUyGNDY2orW1Fc3NzWrJg66uLqVtGBkZwd7enh9Gw93n2Nra8sM8zM3NYWVlBQAQiURwcHBAV1cXOjs7AcgTjq2trfy6YrEYUqmUj5VbrrOzE62trejo6FCKhdumYpLGzs6Oj09TcsPZ2Vmfp5QQQggh4wglPQghE1JHRwcKCgr4nhxZWVloa2uDj48Pn+BYsWIFvL29hQ6VkDGnu7sbbW1tfBKES4yIxWK+90Rvby8kEgm/TktLC7hLio6ODnR3d2vctoODA59YtLKygrm5OQDAxMREqUcJ18NEtdcJTRRMCCGEkKGgpAchZEIQi8X45Zdf+J4cJ06cgFQqRXBwMCIiIhAZGYnbbrsNTk5OQodKCCGEEEIIGSWU9CCEjEt1dXU4deoUcnJykJ6ejsLCQhgbG2P+/Pl8T46oqCilLviEEEIIIYSQyYWSHoSQcUFT+Vhra2ssXbqU78kRGRk56apTEEIIIYQQQrSjpAchZEyqqqpCVlYWMjIykJWVhUuXLsHJyQnLly/HihUrEBUVhQULFsDY2FjoUAkhhBBCCCFjFCU9CCFjQlVVFd+L48iRI7h8+TJcXV0RFhZG5WMJIYQQQgghw0JJD0KIIKqqqpCeno7s7GxkZmaipqYG7u7uWL58OT9cJSQkhMrHEkIIIYQQQoaNkh6EEIPr6+tDWVkZP+no8ePH0djYCA8PD74XR0REBIKCgoQOlRBCCCGEEDKBUNKDEKJ3MpkM58+f55McP/30E5qamuDj48P34rj99tsxc+ZMoUMlhBBCCCGETGCU9CCEjJhUKkVRURE/J8fRo0fR0tICHx8fvhdHdHQ0vLy8hA6VEEIIIYQQMolQ0oMQMmRckoObkyMrKwttbW18kmP16tWIjo6Gi4uL0KESQgghhBBCJjFKehBCBtXR0YHc3FxkZWUhMzMTp06dglQqxcKFCxEVFYUVK1YgMjISjo6OQodKCCGEEEIIIWn7WawAACAASURBVDxKehBC1HR2diI3NxcZGRnIyMjAqVOnwBjD4sWLERUVhaioKERGRsLW1lboUAkhhBBCCCFEK0p6EEKUhqtwQ1Z6e3sRHBzMz8kRFRUFe3t7oUMlhBBCCCGEEJ1R0oOQSWigJAdXXWXNmjWU5CCEEEIIIYSMa5T0GCWdnZ1oaGhAU1MTJBIJJBIJxGIxWlpa+PsSiQQtLS0Qi8WQSCTo7Ozk1+/o6EB3d7fS9rq6utT2IxKJ4ODgoPW+kZER7O3tYWdnBxsbG9jY2MDW1hYODg6wtbXlH+OWcXJywpQpUwx0VshoUU1y5OTkoKenRynJcfvttyv9rRBCCCGEEELIeEdJjxHo6elBTU0Nrl69iuvXr6OhoQENDQ2oq6tDfX09GhoaUF9fjxs3bkAikSita2FhARsbG9jZ2cHe3l4p4cAlIExMTAAAVlZWMDc359e1tLSEhYUFf9/c3FwpIcIYQ0tLi9b7bW1tfGJFIpGgublZKfHS2tqqFKuZmRmcnZ3h6uoKd3d3uLi4wMXFBe7u7nB1dYWLiwumTp0Kb29vajSPEZqqq7S3tyMgIACRkZF8hRWaeJQQQgghhBAykVHSYwDd3d2oqanB5cuXUV1dzf+8dOkSLl++jOvXr6Ovrw/GxsZwdnaGi4uLUmLA2dlZKTHg4uICJycnpYTGWNXa2gqJRILGxkbcuHFDKaFTV1fH3+ee43qlODg4wNvbGzNmzFC6cY9RI9swKMlBCCGEEEIIIeoo6QF5z4eKigpUVVWhpKQEpaWlKCkpwYULFyCTyWBqagpnZ2d4enrCx8dH7ebl5TXmkxiG1tzcjNraWly/fh1VVVVqt+bmZgDypMisWbMQGBiIoKAg/ueMGTNgZGQk8FGMHzKZDGfOnOGTHCdOnIBYLMbs2bP5JMeqVatoaBIhhBBCCCFkUptUSQ+pVIri4mLk5eXh3LlzKCsrQ1lZGa5evQoA8PLywuzZsxEYGIg5c+Zg9uzZ8PHxgaenJzXIR6ilpQWXL19GeXk5ysrKUFpaivPnz+PChQvo7u6Gra2t0rkPDQ3FokWLaLhMPy7JkZ2djZycHBw5cgStra3w8fHhe3HcdtttcHJyEjpUQgghhBBCCBkzJmzSo6+vDxcuXEBeXh5Onz6NvLw8nDlzBp2dnfDy8kJwcDDmzJmDOXPmIDAwELNnz4atra3QYU86MpkMVVVVKC0t5ZMhJSUlOHfuHKRSKXx9fbF48WKEhoYiNDQUISEhsLa2Fjpsg+OSHMeOHcPx48eRnZ0NiUSCuXPnYuXKlYiOjkZUVBQlOQghhBBCCCFkABMm6dHe3o7s7GxkZGTg5MmTKCgogFgshpubm1KjefHixXB1dRU6XDKIrq4uFBUVKSWtzp8/DwCYM2cOFi9ejOjoaERHR8PLy0vgaPWjpKQEx44dw7Fjx5CZmYnm5mYEBgbitttuw8qVKxEVFQVnZ2ehwySEEEIIIYSQcWPcJj06OjqQm5uLjIwMHD9+HKdPn4ZIJMKSJUsQGRnJJzqmT58udKhETyQSCQoKCpCXl4eff/4ZmZmZqK+vh4+PD58AWblyJaZNmyZ0qDqpra1FTk4O0tPTkZaWhitXrsDDw4OfkyMmJob+fgkhw8LNowTI562SyWQA1MufK2ptbUVfX9+g2xaLxZBKpYMuJ5FI0Nvbq/SYnZ0djI2NB11X1wm/bWxsYGpqqvE5BwcHiEQite2pVkAjhBBCyMQ2bpIejDHk5+fj+++/x7Fjx3Dq1CkwxhAWFsZ391+2bBmsrKyEDpWMEsYYSktLcfz4cWRkZCAzMxONjY3w8/NDdHQ07rjjDqxdu3bMDIepq6tDVlYW0tPTcfToUVy6dAlubm6IiorC6tWrcfvtt2PmzJlCh0kIGaLOzk50dXXxCQWusc8lB7ikA5dUaGlpUfrZ2toKmUyGtrY2AOAf4ygmI9rb29HT0wNA3iOOq5wllUohFosNdoympqawsbEZdDkTExOdhor29vaqlXLXZDSPy8jICPb29vxz9vb2/Hxe1tbWMDMzAyAvOW9paQlAXjLeysqKf4xLqHCl5rn1uOQMl/Thts0lZqiyFiGEEGI4Yzrp0d3djYyMDBw6dAjff/89amtrERoaitWrVyM6OhoRERFjpkFLhMcYQ3FxMY4fP47jx4/j6NGjkMlkWLVqFTZu3Ig777wT7u7uoxZPY2MjTp48yffmKCgogJOTE5YuXcr35ggJCeG/iSSEGA7XeG5tbUV7ezskEonS/fb2drS1taGtrQ0SiUTpfldXFyQSCXp6etDe3o7u7m50dHQoJR204RrVZmZmsLa21tpIVmxU69LYVk0uKDaaFXtTcI1vAHwMijQ9Nh4pJo20PdbS0gLukkextwqXtALAv8bAwMknxV4s3Habm5vBGENLSwu/b+7vTpckj0gkgoODA4yNjWFnZ8e/xtzfkK2tLaytrWFtbQ0HBwfY2Njw9x0dHdXuc7/rkqwihBBCJrIxl/RoaWlBSkoKvv32W/zwww/o6elBdHQ0Nm3ahDvvvBNTp04VOkQyTnR1deGnn37Ct99+i++//x719fVYvHgxNm7ciI0bNyIwMFCv+2tvb8fJkyeRnp6O9PR0FBYWwtLSEsuWLeMrrCxcuJAqAREyBDKZDC0tLWhublb7yf3OJSkkEglaWlr43xXvaxrSwTUu7ezs+Aaivb09bG1t+Qakvb09/y09N0RC9dt6R0dHvsHK9Rbgtk2IItXEmWovIa4nD5dUUewl1NHRgfb2drS2tkIsFvN/54r3Ozo6NO5XNQni4ODA37e1teXvOzo6wsHBQeNP6klLCCFkvBoTSQ+ZTIbjx4/jk08+wddffw1zc3OsXr0a69evx8aNG5W6mxIyXCUlJTh48CAOHz6M/Px8BAYGIi4uDg899BDc3NyGvL3Ozk7k5+fzPTmysrJgbGyMkJAQvidHVFQU/y0tIZNVR0eH1sSFtkQG91P123sTExOlxpi9vT3s7e35xpytrS1/39raGnZ2dmr3uSQH12uCkImC62nCJf3a29uVEoPt7e1obm5Wu9/e3g6xWKz0/8f1eOGYmZkpJUEGSpCo/qThO4QQQoQkaNLj7Nmz2LdvHz7//HO0tLRgw4YNiIuLw9q1a7VOTEaIPpSVleHTTz/Fp59+irq6OsTExGDbtm1Yt24d3xVclVQqRVFREd+TIzs7G1KpFAsWLOB7ckRGRtIEeWTCa2pqQkNDAxoaGtDY2IiGhgbU1dWhsbFR433VXhZc9/zBGkmanqPS4oSMjt7e3iElKFUfU728dHJygouLC5ydneHs7AxXV1e4urqq3eeWoS8MCCGE6MuoJz0kEgn27duHDz/8EGfOnMGyZcsQFxeHzZs30zcBZNT19fXhp59+wieffIL//e9/sLCwwJYtW7Bjxw74+vrizJkzyM7ORk5ODo4cOQKJRILg4GBEREQgMjISa9asoZ5IZNxramrCjRs3NCYsGhsbUVdXp5TgUKzcYWdnB3d3d77h4uzsDDc3N6XGDZfE4BIX1JghZOJrbW1VSoQ0NTWpvbdw7zvcTbHaj52dndp7iab7rq6ucHNzoy/LCCGEaDVqSY/r16/jH//4B5KTk2FqaopHHnkEcXFx8Pf3H43dEzIosViMr776Cv/+97/xyy+/wMPDA7W1tQgKCsJtt92G2267DStWrICDg4PQoRKik87OTly/fh21tbVaf165ckWpOoaFhQUcHR3h6ekJDw8PPlmh6f60adMogUEI0ZvOzk40Nzfz709c0kT1fnNzM65evao0/M3R0REeHh78e5Wmn9OnT6fkCCGETEIGT3pUVFRgz549+Pe//42pU6dix44diI+Pp7HUZEzLz8/H66+/jsOHD2PevHnYuXMntmzZAhMTE6FDIwQSiQRXr17FjRs3cPXqVdTV1fH3r127xjcQuEkNTUxM4ObmhmnTpvE/3d3d+fvTp0/nu5lzVT8IIWSsE4vFuHHjBv/ep/hT8T2Sq5xjZGQENzc3PgmimBBRvO/m5kaTjhNCyARisKRHUVERXnzxRaSlpWHFihX4/e9/j3Xr1lF5TjKuXLx4Ee+99x727dsHFxcXvPTSS3jooYeoYUgMqrm5me+NUVVVpXTjHufo8u2ml5cXJewIIZNWV1cXamtrB+z1Vltbi5aWFgDyUtPOzs7w9PSEj4+P0s3DwwM+Pj705R0hhIwjek96XLt2DX/605+wf/9+rFu3Dq+88goWLVqkz10QMupu3ryJPXv24J133oGPjw/++te/Ys2aNUKHRcapuro6VFdX4/Lly6iuruZvly5dQnV1Nf+tpL29PWbMmAFvb2/MmDGD/3369OmYOnUq3NzcKAFHCCF60tbWhmvXruHatWtK78/ce3NtbS1kMhmMjY3h6enJvy9z783czcvLS+uk6IQQQkaf3pIe7e3t2LNnD9544w34+fnhnXfewcqVK/Wx6Qlld4QIO3Plv4cnVSAn0VfYgMiQNDY2YteuXfjXv/6F6OhovPPOO1iwYIHQYZExRiqV4vLlyygvL8eFCxdQUVHBXzRfvnwZnZ2dAOTVDLiLZE0XzzR/DCGEjB29vb24evUqnxC5fPmyUnLk6tWr6O3thUgkgoeHB/9+7ufnB39/f/5GE6ATQsjo0kvS4z//+Q+eeeYZmJqa4o033sDWrVvH3VjIyt0R8NuZC8SngiXHGHZnaQkQxe4dd0kP7hzFpzIY+hQNWf85Ha3YSkpK8Oyzz+LHH3/Eb3/7W7z11lt0ETMJXbt2DeXl5aioqEB5eTl/q6qqQm9vL8zNzfmLXR8fH7Xkho2NjdCHQAghRE9kMhmuXbumlBC5fPky/xlRV1cHAHB1dUVAQAD8/f2VEiK+vr7UQ4QQQgxgRIO8r127hkcffRRHjx7FH//4R/zhD38Yt2McK0rl3S/CA/1uPWiohrRfIML1uDnDq8TuCD/szI1HKsvBWMt3AABiksHYJiSIRBCFJ6EiJxGGTCcFBQUhJSUF6enpeOyxxzB37lwkJycjNjbWgHslQmhubuYvWLleG1yiQyKRwNjYGN7e3vxF69q1a/kLWS8vr3GXACaEEDI8xsbG8PLygpeXF5YvX672fGtrq1qS/ODBg6ioqEBbWxuMjIyUeoYEBATwv3t5edFwRkIIGaZhJz0OHz6Mbdu2wc/PDwUFBQgMDNRnXKMuJpmBJQsdxdhUuXtbf8IjeWwmPHgxSGapgCgWfgn+hu+xA2D16tU4e/YsXn31VWzYsAFbtmxBcnLyuE3+TWZSqRQ1NTUoKSlBfn4+8vPzUVpaikuXLoExBkdHR/j4+CAwMBCbN2/mJ7WbM2cOrKyshA6fEELIGGdvb4/Q0FCEhoaqPdfc3MxPWF1SUoLS0lKcPHkSZWVl6OjogJmZGXx9fbFo0SIEBQUhMDAQS5YsgaurqwBHQggh48uQh7fIZDK88MILePfdd/HCCy/g1VdfnbiZ56H29KjcjQi/nZg72PL9y2FcDG9JQ4IoFsXaYu0/llz+AeGTI/JhOEBSRQ5G8/RmZmZiy5YtcHd3x1dffYWZM2eO3s7JkDQ2NqKoqAhnz57lbyUlJeju7oaTkxMWLFiA+fPnY/78+Zg3bx4CAgJga2srdNiEEEImGZlMhurqapSUlODcuXP8Z1dFRQVkMhm8vLwwb948zJ8/n//s8vPzo4pdhBCiiA2BWCxm69atY05OTuzHH38cyqojV5HEwgEG7hafqvBUuML9CpYUfmu58KQKtccAMIXVNSyfyuKhvLzqPhWlxmvf9kDHEp5UIY99sHVVjx3hLKlC8elwlfiZyjHcWl552dRbxx6exCrUdswtr7w/hQNX2Sd3nm8tr3hu41OVz2u44kb7twWN5yWepWo4D+Eag1I+v6Ot7v+3d+5RTV35Hv8GAbGKgAqK+G6CCvhWtInWV6sCbbXTkXbaKjNTJ1zXtAVn1Xrb6u1LO7c6vU1W66yKtrfQdmaKM47VSlwd7diLpPXV8QGoJBUdX4AIIog8Ivv+kZyTc5KTBxA4EH6ftc6CJOfs/dv7PPf3/PbvV17OFi5cyKKiopjRaOz0+gkxFouFnTlzhn3++efs5ZdfZosXL2bR0dEMAAsKCmIJCQns6aefZv/93//NDAYDu3r1qtwmEwRBEIRH6uvr2bFjx9iOHTvYiy++yObPn88GDBjAALCQkBA2bdo09utf/5q9//777ODBg+zWrVtym0wQBCEbXoseN27cYFOmTGGxsbGspKSkI21yg21QLRqgcwNt28DYRp6WG3g7b2MVKRwG8k4DePt3HkUMzhJ3AoF4RX7w7ixSiNshZRcnCGjz3K/nqa3W713UK9pe6jfbdo5iCdc2R1HKoQ7uO3fCh6g8tZqp+bqcxRVJ27zdcT6mubmZ/eY3v2EhISFsz549stjQU7l69Srbs2cPe/3119kjjzzCIiIiGAAWERHBNBoNe/HFF9m2bdtYfn4+q6+vl9tcgiAIgvApVVVVLD8/n+l0OrZixQo2bdo01rt3bwaARUdHs+XLlzOdTsfy8/PZ3bt35TaXIAiiU/Aqwl5lZSUWLlyIgIAAfP/991CpVJ436hCUSElVA8Zc7DPbvjLvQ64RALKw28CtZ8DuwlSkKAHAhGIjAGMxTLZfk5ZpARhRbBIULUNwUXH2liSs1akBFKKEaxsMSE/OAtQ6ZAvmaSgzsqFTA1nJ6eCb7MJ+VZzEt7Z11bpsZCiTsI0xMMkpKWaUFAJQx8Fpj5tLUAgACbHigKHKFKSqAWTt5m1TxiYAALR59jq4Nhgz06Dn2svbJegXrjxjAtbzwUmVyFgvsQ/tDUScGkBhCcxSP3cwgYGByMrKwrp16/Dzn/8ce/fulcEK/6epqQnff/89tmzZgqVLlyI6OhoxMTFYsWIFDh8+jAkTJuCTTz7BlStXUFVVhcOHD0Ov10Or1WL27NkUd4UgCILwOyIiIjB79mxkZGQgJycHx48fx61bt2A0GrFu3ToEBwdj69atmDNnDsLCwjBr1iysWbMGf/vb31BWVia3+QRBEB2CR9Gjvr4eSUlJCAoKwj/+8Q8MGDCgM+xyiTIlFWoYkWtTPcz7ipFqyoMWQBanehh2ozA1xTZAFg/qDekKKJKz5DG+tbgSFqCEVUcQCiSdjKlYEMdDiLe22QQsl8KFDxAIXXLwxhtvYP369Vi+fDkOHz4soyX+QW1tLQwGA9avX4+5c+ciPDwcs2fPRk5ODmJiYvDuu++iuLgYVVVVOHDgAN555x0sW7YMMTExcptOEIQrzHpoFAooFAooFAIhn2gf1K+EgJCQEDzwwAPIyMjA559/jpKSEty8eRN79uxBSkoKzp49i1//+teIjo5GbGwsfvWrX+GTTz6BySTnUxRBEITvcCt6MMaQlpaGmzdvIi8vDxEREZ1ll2tsb/6Nuftghhn7iuOQokzCMqvqAQMAw+5CpKYIZALBzX/3MgaWp5XL+tZhExZEaXRtWD04OlAw8ATnWeIDb4pC2ZSbjmfDhg1YtWoVfvazn6G0tFRuc7oVFosFJ06cwLvvvouHH34YgwYNwmOPPYb9+/dj8uTJyM7ORkVFBc6cOYM//vGPWLlyJcaPH08pYgmvMes1UKRLDQfN0Gu4AaOHRaOXxaOsO2HWa6x95djXZj00qlykmhist+W2CPkGa6pyN4vkLpayT7RooNFooDdL/a6xeyg6mZPusK5NcBCJEB18HPmkXwl/Z8CAAVi8eDE2bNiA/fv3o6qqCoWFhXjppZdw7949vP3224iNjUV0dDRSU1ORlZWFy5cvy202QRBEm3A7Ovjoo49gMBiwd+/eLpQSSzDFxbAPxXFWjw7rlJUs7DYIp7bAnl1ErYOJeZmFpatgExaMEsqGqdgIQA0JPaRzUGYg2zo/BWmCpz+zXgOrI00CYr3MnJLg7YqtRWpajgzodDpMmjQJzzzzDO7duye3OV2a0tJSfPDBB0hOTkZ4eDhmzpyJXbt2ITExEQaDAbW1tTh+/Dj0ej2WL1+OgQMHym0y0W0xY1+uUTQVzwnbfYMxBpNObfvKBMYYGDNB19lzIrs6tgG/o8hgvV85C/iGLZkwatcjQ2lLG8/aknHL6s3pvH8YmEkHNYCsZAU0UiqFTYiwZvtiDtsZYbS5MyozCsCY1aPUit3b1KkLdts9Sa222KZ1KjNQ4MJOk+1eqvKRR4Zv+pXoafTq1Qvx8fHQarXIyclBaWkpSkpK8Prrr4MxhldffZXPFPO73/0OBw8eRHNzs9xmEwRBeIVL0aO0tBRr167F5s2bER8f35k2eYSf4rKxGHGcupG0zDrFZeNGgJ/aAru3hPC77oIyFtaZIo7eFFysDYG40zEGWKequJgmoswogEmnhjFTxb+tSsN660DAo+BgG3BAi2UdJUQ5TQuSh8DAQGRnZ+P8+fP4wx/+ILc5XYp79+7BaDTilVdewYQJEzBmzBj8z//8D8aMGYPPP/8clZWVOHLkCDZt2oQFCxYgJCREbpMJf0EQD2qj5Gt7LfL4OEJSKJFRIBwIE66wDryZQ9pzA3b7cKYpFztK/KVNnAfnHSrEgHRVJozQIs9RFFBmoMAmfNjfOVjjbqm1WuvLCKfyrGXuztJCZ6vTW0Gfi3Eljk3WVnzbr0TPRqVS4T/+4z+wc+dOVFRU4Pjx41ixYgVOnjyJJUuWIDIyEk8++SQ+++wzVFZWym0uQRCES1yKHq+99hqmTJmC1atXd6Y93mETA4yIEwz6bVNcjLALIQLs3hK24KCOuIxR4f30C+vbLNdvgFzbJPpW9JC1LU9rfQMkeHVmSFch0who1wseyLk+ydxif1Nk1iMt0winaTBu2uqIdRqNa9dY6xsw+xuygpQS5BqlRaasjXb3XbM+DZlGQK1b6xRAVbpfxJhLCt38aB3MSE0LkouhQ4di8+bN2LRpE27cuCG3ObLS0tKC/Px8PP/884iJicGcOXPw3Xff4emnn8bp06dRWlqKDz/8EMuWLUN4eLjc5hJ+imFLLlLzdC4GsEpkFEgFd3YkCdvcCSNOUxootkJnIymGADCkJyML0vcg64Z2wURE3FpY42gLAqrzhe5GlnYZUlpvJTgz/Xm6J9G9CQgIwLRp0/Dyyy/j22+/xY0bN/DRRx8hMDAQmZmZGDJkCB566CHs2LEDVVVVcptLEAQhRiqly+nTp1lAQAA7fPhwx+ePaSN5Wuf0rMykE6Q1Fa8LQJA2lUvTak25auBTqtoWPtWpYD2p9KyS5dsXqYypJse61Dpm4lOwwjllK9cuOLZB0hCnsvME9al1Juf6PaXYtdXt1NfSK0umD+bT6arVrvtHwnaTY//btnHqb4eO9jp1cCdjsVjY+PHj2UsvvSS3KbJw7NgxlpmZyWJiYlivXr3YwoUL2fbt21lFRYXcphE9jjymFV17PV8vJNNsu63CMY24c13C6742T3y9c5fOW3wdt11vHe4Tbu0UXm+tF1WP9y7n+5Cwz5yv1VzZwjZyNkneM6NGsyjJ+62wbDf7yUXadun9xpXZuvuESae2luMmRbw2z0Vaebf2eHkcut0HLvrVxXMLQfiS5uZm9s9//pOtXr2aRUVFsaCgIJacnMxycnLYnTt35DaPIAiCSYoeL774Ips9e3Zn20J0UawPaS6EFgHcA5fTg57tAVHyQdrn2B5mO6eyVrNjxw42aNAg1tjYKLcpncLt27fZRx99xKZOncoUCgWbM2cO+/DDD1lZWZncphE9mTytfdDpYgDrSOtED9t1yHHAyQ1aBdcnu4Bhv8ZK1uUgfIjKU6sFgn8bBtC8PR6Ea0GBkgN7V9d6yT6Wula76DdmYjq1h/a4sdHpfsC33fN9TbyZTfSQtDOPaW3ltVb04MUKd/ctb/dBF78HEv6PxWJh33zzDXvuuedYREQECwsLY7/97W/ZqVOn5DaNIIgejJPo0dLSwqKiotj27dvlsIfokrh4EOZ/5h4gXTyUdpro4eqBuetw+/Ztdt9997GvvvpKblM6lJKSEqbValm/fv1YZGQkW7t2LSspKZHbLIJg1uuZ8FrGvfV3PwBuleghIW7Y63aoS/L6KCFcSHrduRcp3F9zpQfHzp5y7oQIb9riynZ39TuUYdIxtacbiKO3oLt7AbduK+8VdtGDEyrs/ST8zRvRwxvPUIHB3u8DEj2ILsTdu3dZTk4Omz17NgPAZs2axf785z8zi8Uit2kEQfQwnGJ6FBcXo6KiAkuWLHH8ieixKJFRwGDSFSJZFJnfltZRlYmEPM8R4jt0rrIhHQpFMpDHwNwGH5SX0NBQaDQa5Ofny20KAODf//43mpqafFbeyZMn8eSTT2LcuHEoLCzEjh07cOXKFWzevBkqVdeJsUL0YMz7kJuwTBDHwRYPyidBJG24jJvExW7wlELUlqVMzrTkHOYSFAISgaG9bUvrUGastwYlF+wM875ipK71LuI1nxXFFg8rTSpILZdy3UWQbm9IsgURy9xigDUwN5DaisjioiwznjLLdfI+IAhfERISghUrViA/Px+FhYWYPn06nnvuOYwbNw47duzw6fMHQRCEO5xEjx9//BFDhw7FsGHD5LCH6MJwQUvtD2dWMcTdA5teo4DCFjjWmuWlgwL5JW3z/ODYRZg5cyaOHz8utxkAgK1btyIqKgovvPBCu2wqLS3Fz372M0ydOhU1NTX49ttvUVBQgCeffBLBwcE+tJgg2od5Xy6MWcmC4KIKcLGts3ylenCDaqfMW61H9sCWXAY0icDQ1kDXvhZmbCJU1kZY9QoDtuTGtT5TWdI2WHUPlVMKXT4zWnvEAlvGOGTthsG8D7nowGxqnb4PCML3xMfH44MPPsDFixfx5JNPYu3atVAqlfjTn/4Expjc5hEE4ec4iR5lZWWIiYmRwxbCD+FEEfviTUYE/2bo0KEoLy+X2wwAQHNzM+rq6pCVlYUZT7RUywAAIABJREFUM2ZAqVRi8+bNuHr1qlfb19fX47/+678QFxeHyspKHD16FPv378fcuXM72HKCaAsGbMlNhYk5XpdM1pSh/EC7nXCZPxw8Dcx6jU1gSYCX2Uy9TnvaYdgEHKmsWtaMZWr4OlFW0lprutjcfWbAsBtY3zbvvaRt1pTCWcmOYjvn3eMh25pZD41G70K4snsIbUzLRUIbbfQKGfYBQXQUkZGR2LhxIy5duoRf/vKXWLVqFR588EH861//kts0giD8GCfR486dO+jbt68cthBEjyA0NBS1tbVymwEAsFgsUCgUvIvpTz/9hA0bNmD48OGYOXMmsrKyUFdXJ7nt2bNnkZiYiI8//hjbtm3Dd999h+nTp3em+QTROgy7USiRTls4ncTblOOeUGYUwKRT2zzcrB4laVhvFVfUcXA/RjVjX64RgBbL5FaJOa8IJ68VM0oKAag7wMNBmYJUNWDMTINmI9rRB0lYa1WzkOzg7mEVVqx1uBK6DFtykZrtWsywTnEBjMaEjt1PcuwDguhg+vfvj7feegslJSUYPXo0EhMT8cYbb6ClpUVu0wiC8EOcRI/w8HDU1NTIYQtB9Aiqq6vRr18/HDhwAAcOHMDhw4dx4sQJfjl37hwuXLjALzdv3kR1dTWqq6t9fm42Nzc7uZU2NTWBMYZjx47h+eefR1RUFJ599lkcOHCAX/fjjz/GtGnTkJCQgHPnzmHlypVQKBQ+tY0gfIsB6dw8FgmUKakeB8GA9Nt2l2XapgRyS0FKCXKNgFpCeMnaaPcoMOvTkGkE1Lq1Tp5x3tRvLin02kbpKTjC6RJJ2GaLj6ESCAeGdBUyjYBWwsPBaUqOyxgnrlAiY701ZgZSnftACq7Njv2jzMi2efEkQyPcscoMFOTZ4nKoFA5TYKzxqjbGZQviVFmFKGPmFrvXSNJaa9naZSIbrd4Xvpya1Pp9QBDdhWHDhiEnJwd/+ctfoNPpkJKSgps3b8ptFkEQ/oZjZNMvv/ySDRw4kLW0tHR0EFWC6JG89NJLLD4+XjKCf2uX4OBgFhERwS8xMTFszJgx/DJ58mQ2bdo0fnnooYf4ZcmSJWzmzJlMoVB4rCcoKIgpFAoWHR3NFi9ezAIDA9nWrVvl7kqC8A6nzB7iTFN8ylDB4piJw9Xv3uMhHaxaXI9UKlh+UeuYic86I97GqS1SWTyc+kPL8nj7XLRRmOLWZbYbB5vUOmZw7D+rkV5kL8ljWk9pd6XqlMok5mC7Y13O+1+8vdQxIDw+uPKkjxVbPzn1nzdZWxzwtA+86leC6LqYTCY2adIkNnnyZFZdXS23OQRB+BEKxsSveS9evIjRo0fj3LlzGDt2rBu5hOgYDEhXJEP0PlKthhqpyO7CWUnaiiHdHkQQah1MfthGRzQaDR5++GG88cYb/Hd3795FQ0MD/7m2thYWi4X/XF1dzf9vsVhE02MaGxtRX1/Pf75z544oInpNTQ3vLtrS0iLyFvn+++/xf//3f17ZHRQUhObmZigUCjzxxBPYsWMHwsLCvNqWIHo63LVOm+cQcNmQDkVylvP3PR4D0tOBbdQpBNGjqKqqwrx58xAaGooDBw6gT58+cptEEIQfEOj4xahRozBmzBjs2bMHa9eulcMm/8Pbh1qzHhpVJqAzgXE+tbZtjerU1pfXxbEOArTIswU3NaQroEqPBevOjfJAWVkZjh49ik2bNom+79Onj+jGHhER0Sn2PP30025/DwkJQUNDA+6//34kJydj+/bt2Lx5M1544YVOsY8guj2267oRauhM7tN6E3bM+t2IW7tNbjMIguhkBgwYgG+++QaJiYnYsGED/vCHP8htEkEQfoBTTA8AWLFiBT799FNKIdXJGLZkwqjWIVv4VJy0DSadWj6jOgwDdmdBNBc6aZnWJykeuzI5OTkYPnw4HnzwQblNAQCRRwhH7969AQD3338/1q1bh+LiYpjNZtTW1iIxMRHPP/98Z5tJEN0Qa1wIhSoTCXkMjLkXPGRPTSs7BqQrFFBo9DCb9UgrXkYCEUH0UIYMGQK9Xo8PP/wQ169fl9scgiD8AEnRY9WqVbhw4QJ27drV2fb0YGxR2I3FcAxTp8xYD60cJrUFsx4ahWNQODc4ihwJsa2b3mKrT8EvGt+knOwA7ty5g/fffx+rV69GQIDkqdfpcKJHcHAwACAuLg6vv/46SkpKYDab8cYbb2D8+PGwWCzYtWsXnn/+eQpYShBeoeRTdrtyXtNrFFDY5vdZs7w4plbtSagQZ40kC1UakO3HHn8EQXhm2bJlGDx4ML766iu5TSEIwg+QHHkNGzYMq1evxmuvvYbGxsbOtsktZr2GH+Bq9AbrQyP3dsi+knggLBiB8+srFEg32N4s8eVJjJbdlGVbQVSmQjTgt5Vve6jNSnZVBgAoEZsAAFlIFrYFAJCEbQUZUHpTns/aLv7dqY8d1063raPK9DJKvy2VoDETaXqztb5kIK81D7qGdChUxVjPZ0cwQaeWisTfNXjvvfegUCjw29/+Vm5TeBhjmDBhAt566y389NNPKCoqwiuvvAKVSpxQ8+rVq7h9+zalpCUIH8KJIvZlm1eZSvwTu0jEekBsJ4Ig3KNQKDB9+nQUFxfLbQpBEP6AqwinN2/eZNHR0ezll1/u+HCqrYWPUK5mOhMXud0WxZyLhM+FXueinQtCmNsjrNsjn3PfqcUh/T2UZYt2r9YxE7+JROR4Wzkeo6h7FR3fTXk+a7u1XcK+MOnUona6boLauf2u1xZkC7Db4xxJX6ofXGRCkGhzV+DkyZMsODiYffHFF3KbIuLWrVterXflyhUGgJ0/f76DLSIIgiAIgmDskUceYWvWrJHbDIIg/ACXPvYDBgzA9u3b8d5772H//v0dKLu0AVUc1ADUumxkKJOwjX9DZkB6chYgjIuhzMB6LYCs3bzbsNLqUgFtnv2tmjIjG1bHgzTb9AhvyjKh2AjRlJSkZVoARhQ7zlHxBmUGClieYCpLFpIVCi9dnn3YdvM+5BqBhFj7uzZlRjZ0cJ560y4MW5Ap4RaStI2B5Wltdnb/t581NTX4xS9+gaVLl3oMHNrZeJt9ZejQoYiKivI60wtBEARBEERbaWpqwg8//IApU6bIbQpBEH6A28ACKSkpWLduHZ566ikUFRV1lk1tx1yCQgDq1BSRa6wqTg0gC7vdKgdKpKSqwQsWXpUlFFxsUzySs5yLbhVcmY7ihwfhw5dtV6YgVc1Nn+FiZCiRUeA78cGs10CRDOQxTuDIQrLjnBRtnpvsNJwrtNgm875cGAFol3UNmcRiseCpp54CAGzfvl1ma9qOQqHAihUr8P7776O5uVlucwiCABymM7YtHki65NRMd/W4mAraFnxgP0EQ/smOHTtgsViwdOlSuU0hCMIP8BhN8e2338bDDz+MRYsWoaSkpDNsajumYhjBBYSzP6CppNwJ3FBYYva+LMFD2+5ldg+F9uMofngQLnzZdiiRUWCCNWmMNUaGTx90YcCWTKM9cwuXoSYr2RaDxAz9xkLo1rZOuDDrNbBm/O0aqXwtFgtWrFiBEydOYO/evV57VXRV/vM//xM3btzASy+9JLcpfg0ft8iHgWk6okzCezqk/816aFS5SDUxWG87hch7ofX1bGPMc4YwZQYKvFmvNUjY3+MT2LQS+c5rqZhfGmjcxP3qzvAxyzzENiN8x+nTp/HKK6/g9ddfR//+/eU2hyAIP8Cj6BEQEIAvvvgC06dPx/z587u2xwc/7cXkEBzOfQR9RxJild6VZdZDo7KmmTW1onxJzHpoJB9cbAE/PeHLtgMQBZUz6WANqq/yTYBQw244+sNwU2yQlQyNJg25qdlepyvkHvzSkO0xLWRn0dTUhGeeeQYHDx7EwYMHcf/998ttUrsZNGgQdu7cie3bt+PNN9+U2xy/xVRsFSrVcSoPa8pbJuE9HdH/hi2ZMGrXI0NpmxLICpDc1LZ6lCmp8EbO8HY9b5CyP8OU7t7jpKdikO4XWc5rsx4aRTIKhc8aeVrAaBQHMXdhc3fDkK5AcpbW6pXKGPISMqHq7o3q4pSUlGDRokV45JFH8OKLL8ptDkEQfoJXeTODg4Oxc+dOPPDAA5g9ezYOHDjQ0Xa1DWUsEgAYc/c5K/GGdA+eCmbsyzUC0GJZkpdl2bwrHKeUtJmsjW7Srarh9rnGl213XN8p1kg7sQk04nS1SmQUWOswGo2ieCLu7NZrOLGDoaArqB0AqqqqsGjRIhw+fBgHDx7EhAkT5DbJZ8ydOxd//etfsWnTJqxevRoNDQ1ym+R3WAeAvj2eO6JMwnt83/8G7JaYSdl99rO0/UTrkGN/G7ZYX/RkC+vkvDX9Dttxynmlwha3TfTsQviSAwcOYM6cOZg1axY+/fRTBAR4NUwhCILwiNdXk+DgYOTm5mLVqlVITk6GTqcDY6wjbXONTWxwxp4GVeWYxnVjnPgmDSBro91N0axPQ6YRUOvW2m5u3pdl5KOW2oKJuqDQo++uVLpV61QQa9BWd+X5su1Wrw6R8GEuQSEnirjB+ubJiNx9btpqixniZKvAAyQr2ZPLrgHpChUyjc5TeqyLxo2A1HGcPHkSs2bNQnV1NY4cOeJXggdHcnIyvv32W+zduxcajQYmk0/D2xIEQRBdEjNKCiEK3s6hzFjvuxcjHY1tWrLXDhuOIkdCbOtedDnExJHr+aQrY7FY8Oabb2LJkiVYsWIFdu7ciaCgILnNIgjCn2hLypfs7GzWt29ftnTpUnbz5s225Y1pI/aUqxCkrXVaSZz61THVKpfaVS0uSzLLqYeyxOlVtSyPcSl0hesKvpOyh6tHrWM6p3StUna5Kc8XbTfpmFbt2M8u0udK9oOHPnW1DbeypzZI9YHT4m3aXN/Q0tLCtm7dykJCQthTTz3Fbt++3XmVy0RFRQVbvHgx6927N3v11VdZXV2d3CbJD59O25ryWXy9sp1DDse3MDW0PYWzQ/psqeNddF64/l2yTIGd0OaJP3tzzZE6bwUI69TmibdVS52Yjue8ZJptMLUuz162q+ur1DXDKR24dFrxdvWHi5Tevul/oakS+0CtY8+7PHbc96/wd6d6na7FaqZ2tQ/tG4na7NgeafsXswWejq12HSOsdeu6qcuXx7bn/nJx3mnzZDmvRfvPZQp71zZ70yet61/vz0OR7V6cZ3ZT1YK685jWw7OQRKVM/Pxk39/e1N8T+Mc//sHi4+NZREQE+/vf/y63OQRB+CltEj0YY6yoqIglJCSwIUOGsF27dvnSpo7H9iDQI284PbntHcTFixfZokWLWJ8+fdi2bdvkNqfT+ctf/sKGDx/OYmJi2CeffMKamprkNkleHIQPxpj9IV+tZmr+oZx7+JUegNsf8K3rCR/4TTq14OHe0+9SZTLxwIO/IHA2CR/SbQMLJ7vdP/zbB5f29cQDCBe2cXaJR8oCsYIb6GhZXhvbztnhKPZ61x9e1OlIu/pfskBrHzheyKXq8aZ/pUQPF8ehy8G9cB1BX1gHmo4itHv7ne5P7TpGJHC3rhd1+e7Y9rK/vO0XYR0ddF47C4ju+7gt+9K7/m3DeSgqy9sXI0JRym6Ps3gn1Q8u+lTq+O2BnDlzhj3++OMsICCAabVaVlFRIbdJBEH4MW0WPRhjrKGhgb366qssMDCQ/fznP2elpaU+MquD6ckD/57cdh/T2NjI3nvvPRYaGsrmzJnDSkpK5DZJNurq6tiGDRtYaGgoGzlyJPvggw9YfX293GbJg+2BVjwwdPHwK3U+Om4v+RbexHRqseeIy99d2iQ98HQaEEhsKykaOCJ5rXEUehwHXtymDn0lab83bZcu3+0g0Mv+cNvfjrSn/yVxIRo41dO6/nXyMHDhMeNa9JAQGySPg9aIHu08RqRwua6Xdfns2Payv1zdt+U4r0V2uxn0t2dfetO/bTkPXfWF26ZqW9lGKZtJ9BDyww8/sKVLlzKFQsEWLlzIfvzxR7lNIgiiB9CuCEG9e/fGpk2bcOTIEVy7dg3jxo3Dyy+/jFu3brWn2E7Dc4wN/6Unt729MMawc+dOxMXF4fe//z3effddHDp0CCpVz82M0bdvX7z11lu4dOkSnnvuObz55psYPXo0NmzYgEuXLsltXvfGFgMnK1k4F1yJjIJt1hg8nn73Uf32IMkOgY9bVxhSrAF9UGyCLVaQczBoVZwaHtN0C2xz2XZb+c5z8JWITQDalCa1o/vbl7S1f23xlVofpJtLtW7tC0O6Ago3ca68or3HSKfV1ZZjuwP6y1vadV5zdgsDnGchWZEOt13ky/7thPPQrNdAkQxr5pY8LYAsJDsGAtHmucmOx2XBE9tk3pcLIwBt6y+g3ZampiZ8+eWXmD9/Ph544AG0tLTAaDTiwIEDmDJlitzmEQTRA/BJWOSpU6eioKAAO3fuxN///nfcf//9ePfdd9HY2OiL4n2KXmN/qLAGwPRwk/YjenLbfcXRo0cxd+5cPPvss0hJSYHJZMLq1aspwriNiIgIbNiwARcvXsRrr72GXbt2YcyYMUhOTsbu3bthsVjkNrEbokRGgcma0tkW7FihUAgCDXv63Uf1IxMqhQIKhQqZRi3yWPsGF4Ul9gxYjsGIVZnSoapd2uaq7VyGLYnUV9aBlm0A1So6ur99SBv711xS2PY6BUEbdy/jBovtoN3HSOfX1apj29f95TW+OK8dxQ8PwoUv+7fDz0NrEHk+cwuXoSYr2RZk3Qz9xkLo1rbuKmjWa6DKBHQm5kYs8R9MJhPWrVuH4cOHY9WqVVAqlTh16hT27NmDWbNmyW0eQRA9CJ+O1B599FEUFRVh/fr12Lx5MyZMmID//d//7VLih1V1Fy5d8O1cB9GT295ejh07hieeeAIPPPAAhg0bhvPnz0Ov1yM8PFxu07okffv2xQsvvICioiIcPXoUw4cPxzPPPIPBgwdj5cqV2Lt3LwkgrUJpP39NOliTH6kE2Qc8/d5ODFuQmZDn02tHQqyST1+t1pkcrk3WxbtBgZu228o3Sigb1kxTHlKBt6XOrkQb+1dpdYNpPWY9NCprSlOT1/vPAz45Rjq3Lq+P7Y7or9bQ2vParIdG8iC3ZY/zhC/7F0CHnoeCbHIcyoxsq8iSlQyNJg25qc5Z9Vxh1mugUCiQhmwwVuD1dt2Rq1evQq/XY/bs2Rg7diy+/vpr/O53v8OlS5ewfft2v8xqRxBE18fnr6eDg4OxZs0amM1mPPHEE1izZg1Gjx6Nd955B1VVVb6ujiA6jJaWFuzZswdz587FzJkz0dDQgO+//x5/+tOfMGrUKLnN6zZMmzYN27Ztw5UrV7B582aUlZXh8ccfx6hRo7BmzRrk5+fj3r17cpvZdTGki99eKjNQIHQr9/S7L0zY7SuXewcXemUsEiB0sRdWmu75ra2nttvKd0o5yaXeVKcipbWDj07ob5/R1v5NWgatq+3cwXnWtHpajBvae4x0Wl1tOLY7or9aQZvO66yNbtKtehARfdm/HX0e2gQa8bVDiYwCax1Go1EgvrjDDL2GEzsYCvxU7bh8+TL++Mc/Yt68eRgxYgTef/99qNVqnDhxAkVFRVi3bh0GDBggt5kEQfRgOswnPyIiAr///e9x5coVrFu3DllZWYiJicHKlStx/vz5jqqWINpNY2MjcnJyMGHCBCxfvhwjR47EmTNnsG/fPiQmJsptXrclIiICzz33HL755htcu3YNr776Kn788UfMnz8fgwcPxrPPPosvv/yy28QE8oSUd4EjktMIbAMhUVmZKvEDvrkEhYK5955+lyqTx0kQACSnfWQli1zSvZ0el7VRz5dv1qch0wiodWttb5Rtb4iNmVAJX8+a9dBsjEM2N0BwY7/7tidhW57WqXxDugqZRkC7PsN5sOlFf3jsb0d80f/e4FRP6/rXHuvJvl0a304z9GmZrtshtJ433oD0NsSoEMecav8x4oTLdb2sy4ZPjm14319OsbhkOa+tU0nE3hTWqSBqnbPnQ5v2JWea2/5tw3low+rlZUTuPjciiy1miJOtAg+QrGSFbaqLKwxIV1ivNY5TeqyLxo2A1LVpaWnB0aNHsWHDBkyZMgUjRozAO++8g4kTJyI/Px+lpaXYvHkzxesgCKLr0AHBUSVpbm5mf/7zn9n06dNZr1692KOPPsr++te/soaGhs4ygSDccvLkSZaZmckGDRrEBg4cyF577TV2/fp1uc3yeyorK9lnn33GUlNTWVhYGAsMDGRz585lb7/9NjMajay5uVluE71HFOmfy1LgnOlAmyeR8lCbJ0jVKEg5adIxrVrtOlOCh98ly3S0U5D+Vfi9VGYHx8VlAgIuNaWDbZLrO6bBFGR3cK5XnIHCbd+4Kt9FFgav+sPbOn3c/65ttfapZD1t6V/J1KG2fs8TliPdZvFxrWV5wuNfrWMmF/bbthafK8IsH209RjztD6l13dQl3AftPba96i8X/WKQ47w26ZharWM6p3StUuu3bV963b+tPA+d+9qLa5jUNtzKntog1QdOi7dpc7sGV65cYZ9++ilbsWIFGzx4MFMoFGzGjBnszTffZCdOnGAtLS1ym0gQBOESBWOMoZP57rvv8PHHH2PXrl3o3bs3fvGLX2DlypX0Fp3odCoqKvDFF18gOzsbp06dglqtRlpaGp555hn07dtXbvN6HM3NzcjPz8f+/ftx8OBBnDx5Ev369cO8efOwcOFCLFiwAPHx8VAoFHKb2nOwxR2AzuTgmm1AuiIZWdo8MKnJ+IZ0KJKzoM3rGQH7iB6EPxzbbT2vOwN/6F8/4ObNm8jPz8eBAwdw8OBBnDt3DlFRUViwYAEefvhhJCcnY8iQIXKbSRAE4RWBclQ6d+5czJ07F1u3bsXf/vY3fPrpp5g1axbGjRuHtLQ0PPXUUxg5cqQcphE9gPr6euTl5SEnJwf79+/HkCFDsHLlSuTm5iI2NlZu83o0QUFBWLBgARYsWADA+tBlNBpRUFCAnJwcZGRkIDQ0FDNnzoRGo8Hs2bMxe/ZshISEyGy5/2LYkgkjtMhzmouuQpwXsQsJguh60HlNOHLt2jUUFBTg8OHDKCgowL/+9S+EhIRArVbjl7/8JR566CFMmTKFstURBNEtkcXTQ4rS0lLk5OTgs88+w08//YTJkyfjsccew2OPPYapU6fSm12iXZSXl2Pv3r3Ys2cPDhw4gICAADz++ONIS0vDggUL6CbeTbhy5Qry8/NRUFCA/Px8FBYWIjg4GDNmzMDMmTMxc+ZMJCYmYsSIEXKb6jdYUywaoXZ4I2xPvegiE4Htba3jdgTR7fGDY7vN53Vn4Af929W5c+cOfvzxRxw7dgxHjhxBQUEBrl69isjISGg0GsyZMwcajQZTp05FUFCQ3OYSBEG0my4jeggpKirC119/jb1798JoNCIyMhKLFy/G8uXLsWjRIvTu3VtuE4luwIULF7B37158/fXXOHToEMLDw5GUlIRHH30US5YsQWhoqNwmEu2kpqYGBQUFMBqN+OGHH3D8+HHU1NRg8ODBSExMxIwZM5CYmIipU6ciMjJSbnO7LdwASYRaB1OBRCBQAHqNAuLVtcijFNmEH+BPx3Zrz+vOwJ/6t6vQ1NSE4uJiHD9+HEeOHMHRo0dRXFwMxhjGjx+PxMREqNVqaDQajBs3Tm5zCYIgOoQuKXoIuXLlCvbu3YuvvvoKhw4dQnBwMObOnYt58+Zh3rx5mDx5Mnr16iW3mUQX4Nq1a/j2229x6NAh/POf/8SFCxcQFxfHewzNnDmTPDp6AEIX3RMnTuDEiRNoaGhAREQE4uLiMG3aNMTHxyMuLg7Tp0+nqTEEQRCEX1BdXY2ioiKcOHECxcXF/P8NDQ2Ijo7GtGnT+GX27NmIiIiQ22SCIIhOocuLHkJqa2vxzTff8APb4uJihIeH48EHH8T8+fMxb948TJw4kQa2PYSysjJe4Dh06BBKSkowcOBAXhRLSkqCUkmusT0d7i3X6dOncebMGZw6dQqnT59GeXk5goKCEBcXhwkTJmDixImYNGkSJk6cSMHZCIIgiC5LY2MjioqKcPr0aX45deoUKisrERwcjPj4eEycOJFfJk2aRN6OBEH0aLqV6OFIeXm5aNB7/vx5DBgwAGq1GtOnT8f06dMxY8YMREVFyW0q0U4aGhpw6tQpHD9+nHfRPHv2LCIiInjRa/78+UhISCDRi/CK8vJy/kGRE0SKi4vR1NSEqKgo/kExISEB48aNg0qlwsCBA+U2myAIgughNDU1obS0FOfOncPZs2f5+1VJSQksFgtiYmJEwsaECRMwbtw4BAbKkqeAIAiiy9KtRQ9Hrl27hkOHDvFz+0+ePIm7d+9ixIgRvAjCCSHh4eFym0u4oLm5GYWFhbzAcezYMRQWFsJisUCpVGL69OlITEzEgw8+iMmTJ5PIQfiM5uZmnDt3TvTmrKioCFeuXAEADBw4ELGxsRg7dixUKhViY2MRGxsLlUqFPn36yGw9QRAE0d1gjOHy5cswmUwoKSmByWTCuXPnYDKZcPHiRVgsFvTt2xfjxo3jvREnTJiASZMmkRBPEAThJX4lejhisVhEg+fjx4/j9OnTaG5uxqhRozBu3DjEx8dj/PjxiIuLw/jx40kM6USam5thNptRVFSEc+fO8X/Pnj2LxsZGjBw5UiRUTZs2jfYPIQuNjY24evUqioqKUFxcjAsXLuDChQsoLCxEWVkZAPAxQ+Lj4zFmzBiMGTMGcXFxGDt2LL11IwiC6OFUV1fz944LFy7w95Pz58+jrq4OgYGBGDFihOj+wd1PRo0aRS94CIIg2oFfix5SNDY28m9xuYH22bNncenSJTDGMHToUF4AGT9+PEaNGoWRI0di9OjR9Ca3Ddy7dw/Xrl3DpUuXUFpaCpPJhLNnz6K4uBgmkwnNzc0IDw/H+PHjER8fj3HjxiEhIYGybRDdhhs3buD8+fMoKSnm9yG8AAAHSUlEQVQRLWazGY2NjQgODsaYMWOgVCoxcuRI0TJq1CgMHjxY7iYQBEEQ7eTu3bu4ePEiLl26JFq4Z5/KykoAwNChQ528BceOHYvRo0dTeliCIIgOoseJHq64c+cOzp07h+LiYhQXF+Ps2bM4d+4cLl26hIaGBgBAVFQUP1ARDlpGjhyJqKgoREZG9jglvra2FtevX+eFjYsXL4pu+pcvX0ZzczMUCgWio6OhUqlEnjVxcXEYOnSo3M0gCJ/T0tKCS5cu8e7KP/30k+hB+ObNmwCAkJAQ0TVFeG0ZNWoUoqOje9x1hSAIoqtRW1sr+ZzDLeXl5QCA3r17Y/jw4aJruVDg6Nevn8wtIQiC6HmQ6OEF169f5290whscd+Orr68HACgUCkRGRiIyMhJRUVEYMmQI/3nIkCGIiopCWFgY+vXrh4iICISGhqJfv35dwoPk3r17uH37NmpqalBXV4e6ujrcunULN27cQGVlJcrKylBRUYEbN26goqICZWVluHHjBi8I9erVC0OHDuUHao6DuBEjRqB3794yt5Igug51dXX8W0DHh+dLly7x02aCg4OdHqBHjhyJIUOGICYmBtHR0TSvmyAIoh00NDTwL3C4xfHaXFVVBQDo06cPRo8e7SRUc9fn6OhoKBQKmVtEEARBCCHRwwdUVlbygoBQHCgvL0d5eblIKKirq3PavlevXujfvz8viHBLUFCQ6I1ASEiISCC57777nISE6upq/n9OyOBobm5GXV0d/7e6uhp1dXWora3F3bt3newKCgqSFHCio6NFYs7gwYMRFRVFbpkE4UMaGhpEAqvw4fvf//43ysrK0NTUBMB6bYiOjsbQoUNFC/dddHQ0YmJiEBYWJnOrCIIgOo+mpiZUVFTg8uXLKC8vx5UrV1BWVsb/vXr1Kq5fv8573gHAoEGDEB0dLfkCh/PsJQiCILoXJHp0Mowx3Lp1C7W1tbxHhdDDgvv+1q1bAKw37Dt37vDb3717l/euAKzTcriBT0REBP99QECAaIATGBiI0NBQAFaxhBNWIiIiREJLWFgY+vfvj379+iEkJKRD+4IgiPZRUVGB8vJytw/05eXlsFgsAKznfkxMDIYMGYJhw4bxfwcPHoyhQ4ciMjISgwYNwqBBgyj4KkEQXZbbt2+jvLwclZWVuHHjBq5evcpf+4TXQm7KCQCEh4d7FIajo6PJK5UgCMIPIdGDIAjCj2lpaUFFRQWuX7/Ov9UUunBfu3YN169fR0VFBe7du8dvN2DAAF4EEU7b40SRQYMGYfDgwfw6JJISBNEWGGOorKwULZyXLPeZ85jlPjc2NvLbh4aGOom5nIDBfR8TE9MlphITBEEQ8kCiB0EQBAEAokGG1MCjoqJCNPDgvMwAoF+/foiKinISRqKiohAREYHw8HBEREQ4/U8QhP9QX1+PW7duobq6GtXV1aL/q6qqePHC8VojFFwjIiJE15HIyEgMHjyYBFeCIAiizZDoQRAEQbSJmpoa3sXclVBSWVmJqqoqfgDU0tIiKsOdIOLpf4ojRBC+5/bt25Kihav/hZ+FHhgA0LdvX/6c5bzH3AkYgwYNovOaIAiC8DkkehAEQRCdRk1NjdeDKcf/HQdU/fr1Q3h4OPr27Sv6v2/fvggNDUVYWBj/uX///ujfvz//OSwsDKGhofzn8PBwmXqEINpHQ0MD7ty5g5qaGtTW1uLOnTu4c+cObt26xccOE37mfq+urub/52KJSQmTnMjYFnEyODhYpl4hCIIgCDskehAEQRDdgvr6eicx5Pbt2y4HcNzn2tpa1NTU8J+FWa2E9OvXjxdBuCDP3GcuW1bfvn0RHByM0NBQBAYGon///ujVqxfCw8MREBDA/w0LC+MDSHOZuHr37o377ruvk3uNkAsug5rFYkFtbS0fmLyhoQF3797lA5PX19ejsbGRz652+/Zt3Lt3DzU1NWhpaUF1dTVfhuNxzK3rSHBwMH8cc8ewJ2EwLCxMJFpwwgWlXyUIgiC6OyR6EARBED2O27dv82+9ucEjN5iUemPuagDb2NiI+vp6pwGsO7j043369EFISAgvpAjTkAsFEi6tOYdwIMqJLwD48gCIUp47ZvMKCwtDQECAS/u8ibXCDao9waVfB+BygC7EMdW6KxwzmTkizGzGiQwA+P3HIUzzLrRPuB+FWdQc7bt16xYYYyKBgsvS5onWCGV9+vTx2mNJ2OcEQRAEQZDoQRAEQRA+h3trX1tbC4vFwg+KuUFydXU1WlpaUFNTIxpIuxp4c+IK4HrgDYCvDxALA47pz3sKwnTtgFjQ4bx0AIgEJ6Gg405w4sQFbn1HMYsrk1uPE6g8iU4EQRAEQfgWEj0IgiAIogfBiS2eEHpLuEMourQVoejgDm+mW3DiA0EQBEEQBECiB0EQBEEQBEEQBEEQfgr5VxIEQRAEQRAEQRAE4ZeQ6EEQBEEQBEEQBEEQhF8SCMAgtxEEQRAEQRAEQRAEQRC+5v8BySWwABae2CcAAAAASUVORK5CYII=" alt="Procedures for failed check-in" width="100%" />
<p class="caption">
Figure 3: Procedures for failed check-in
</p>
</div>
<!-- <br><br><br><br><br><br><br> -->
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
</div>
</div>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-confirmation_checklist_2011" class="csl-entry">
Fish Passage Technical Working Group. 2011. <span>“A <span>Checklist</span> for <span>Fish Habitat Confirmation Prior</span> to the <span>Rehabilitation</span> Fo a <span>Stream Crossing</span>.”</span> <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf</a>.
</div>
<div id="ref-mcphail_carveth1993FieldKey" class="csl-entry">
McPhail, J. D., and R Carveth. 1993. <span>“Field Key to the Freshwater Fishes of British Columbia.”</span> <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/field_key_to_freshwater_fishes_of_bc_field_size_water_resistant_version.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/field_key_to_freshwater_fishes_of_bc_field_size_water_resistant_version.pdf</a>.
</div>
<div id="ref-fish_passage_assessments" class="csl-entry">
MoE. 2011. <span>“Field Assessment for Determining Fish Passage Status of Closed Bottom Structures.”</span> <span>BC Ministry of Environment (MoE)</span>. <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
